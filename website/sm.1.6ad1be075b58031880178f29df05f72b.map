{"version":3,"sources":["webpack:///./lib/models/EventEmitter.js","webpack:///./lib/models/ListBase.js","webpack:///./lib/useApi/index.js","webpack:///./lib/utils/cx/index.js","webpack:///./lib/utils/extraPropsGetters/index.js","webpack:///./lib/Context.js","webpack:///./lib/common/HeightProvider.js","webpack:///./lib/common/ScrollContainer.js","webpack:///./lib/utils/useStore/index.js","webpack:///./lib/models/FixedSizeList.js","webpack:///./lib/models/VariableSizeList.js","webpack:///./lib/common/Scroller.js","webpack:///./lib/commonDefaultProps.js","webpack:///./lib/common/RowCountWarningContainer.js"],"names":["EventEmitter","this","_T","Object","create","_proto","prototype","_a","eventName","_fn","prepend","once","eventsQueue","that","originalFn","apply","off","arguments","on","fn","prependListener","prependOnceListener","idx","indexOf","splice","emit","a1","a2","a3","a4","i","evt","argsArr","j","argLen","length","call","Array","removeAllListeners","removeListener","addListener","getRowDataInitial","Error","ListBase","_EventEmitter","_inheritsLoose","Derived","_this","totalRows","startIndex","endIndex","virtualTopOffset","widgetScrollHeight","overscanRowsCount","estimatedRowHeight","scrollTop","widgetHeight","widgetWidth","rowKeyGetter","undefined","rowDataGetter","rowsContainerNode","scrollContainerNode","increaseEndIndexIfNeeded","debounce","currentVisibleDist","getDistanceBetweenIndexes","updateEndIndex","_assertThisInitialized","updateWidgetScrollHeight","cancel","updateStartOffset","set","paramName","paramValue","merge","params","k","destructor","reportRowsRendered","_this$getVisibleRange","getVisibleRangeStart","newVisibleStartIndex","remainder","newStartIndex","Math","max","overscanOffset","newEndIndex","min","scrollToRow","index","node","clamp","scrollToStart","reducer","x","useApi","subscribeEvents","API","useContext","Context","up","useReducer","useLayoutEffect","_j","cx","baseClass","extraClass","getPropsGetter","propName","data","getExtraProps","_props","props","extraProps","assign","getRowProps","getCellProps","createContext","SUBSCRIBE_EVENTS","el","React","createElement","className","memo","style","height","cloneElement","ScrollContainer","forwardRef","_ref","ref","children","onScroll","reportScrollLeft","_objectWithoutPropertiesLoose","scrollHandler","useCallback","e","_e$target","target","scrollLeft","resizeHandler","_ref2","width","useResizeObserver","onResize","_extends","tabIndex","HeightProvider","useStore","StoreConstructor","dataRef","finalDataRef","useRef","Store","current","useEffect","FixedSizeList","_ListBase","updateEstimatedRowHeight","firstElementChild","offsetHeight","distance","SegmentsTreeCache","Uint32Array","VariableSizeList","sTree","N","shouldResetInvisibleRowHeights","setVisibleRowsHeights","newHeight","_assertThisInitialize","l","r","rowHeightsSum","rowCounter","child","nextElementSibling","parseInt","getAttribute","round","calculateParentsInRange","maxWait","resetCache","reallocateCacheIfNeeded","markResetInvisibleRowHeights","dist","v","nodeIndex","fill","suggestedN","pow","ceil","log2","res","Component","useApiPlugin","commonDefaultProps","fixedSize","rowCount","RowCountWarningContainer"],"mappings":"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","file":"1.b02dab87e83687cf4697.js","sourcesContent":["var EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    this._T = Object.create(null);\n  }\n\n  var _proto = EventEmitter.prototype;\n\n  _proto._a = function _a(eventName, _fn, prepend, once) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!eventName || !_fn) {\n        console.log(eventName, _fn);\n        throw new Error(\"Wrong eventName/fn provided\");\n      }\n    }\n\n    var eventsQueue = this._T[eventName];\n\n    if (once) {\n      var that = this,\n          originalFn = _fn;\n      /*\n          when using ...args and arrow func, babel is making unnecessary arguments copy.\n          Going old-school here for perf\n      */\n\n      _fn = function fn() {\n        originalFn.apply(that.off(eventName, _fn), arguments);\n      };\n    }\n\n    if (!eventsQueue) {\n      eventsQueue = this._T[eventName] = [];\n    }\n\n    eventsQueue[prepend ? \"unshift\" : \"push\"](_fn);\n    return this;\n  };\n\n  _proto.on = function on(eventName, fn) {\n    return this._a(eventName, fn, false, false);\n  };\n\n  _proto.prependListener = function prependListener(eventName, fn) {\n    return this._a(eventName, fn, true, false);\n  };\n\n  _proto.prependOnceListener = function prependOnceListener(eventName, fn) {\n    return this._a(eventName, fn, true, true);\n  };\n\n  _proto.once = function once(eventName, fn) {\n    return this._a(eventName, fn, false, true);\n  };\n\n  _proto.off = function off(eventName, fn) {\n    var eventsQueue = this._T[eventName];\n\n    if (eventsQueue) {\n      var idx = eventsQueue.indexOf(fn);\n\n      if (idx !== -1) {\n        eventsQueue.splice(idx, 1);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.emit = function emit(eventName, a1, a2, a3, a4) {\n    var eventsQueue = this._T[eventName];\n\n    if (eventsQueue) {\n      for (var j = 0, i, evt, argLen = arguments.length, argsArr; j < eventsQueue.length; j++) {\n        evt = eventsQueue[j];\n\n        switch (argLen) {\n          case 1:\n            evt.call(this);\n            break;\n\n          case 2:\n            evt.call(this, a1);\n            break;\n\n          case 3:\n            evt.call(this, a1, a2);\n            break;\n\n          case 4:\n            evt.call(this, a1, a2, a3);\n            break;\n\n          case 5:\n            evt.call(this, a1, a2, a3, a4);\n            break;\n\n          default:\n            if (!argsArr) {\n              for (i = 1, argsArr = new Array(argLen - 1); i < argLen; i++) {\n                argsArr[i - 1] = arguments[i];\n              }\n            }\n\n            evt.apply(this, argsArr);\n            break;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.removeAllListeners = function removeAllListeners(eventName) {\n    if (eventName) {\n      this._T[eventName] = [];\n    } else {\n      this._T = Object.create(null);\n    }\n\n    return this;\n  };\n\n  return EventEmitter;\n}();\n\nEventEmitter.prototype.removeListener = EventEmitter.prototype.off;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\nexport default EventEmitter;","import _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport clamp from \"lodash/clamp\";\nimport EventEmitter from \"./EventEmitter\";\nimport debounce from \"lodash/debounce\";\n\nvar getRowDataInitial = function getRowDataInitial() {\n  throw new Error(\"getRowData must be provided\");\n};\n\nvar END_INDEX_CHECK_INTERVAL = 400;\nvar DEFAULT_ESTIMATED_ROW_HEIGHT = 16;\n\nvar ListBase = /*#__PURE__*/function (_EventEmitter) {\n  _inheritsLoose(ListBase, _EventEmitter);\n\n  var _super = _createSuper(ListBase);\n\n  var _proto = ListBase.prototype;\n\n  _proto.set = function set(paramName, paramValue) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!this.hasOwnProperty(paramName)) {\n        throw new Error(\"Trying to merge key, which does not exist: \" + paramName);\n      }\n    }\n\n    if (this[paramName] !== paramValue) {\n      this[paramName] = paramValue;\n      this.emit(\"#\" + paramName);\n    }\n\n    return this;\n  };\n\n  _proto.merge = function merge(params) {\n    for (var k in params) {\n      this.set(k, params[k]);\n    }\n\n    return this;\n  };\n\n  function ListBase() {\n    var _this;\n\n    _this = _EventEmitter.call(this) || this;\n    _this.totalRows = 0;\n    _this.startIndex = 0;\n    _this.endIndex = 0;\n    _this.virtualTopOffset = 0;\n    _this.widgetScrollHeight = 0;\n    _this.overscanRowsCount = 0;\n    _this.estimatedRowHeight = DEFAULT_ESTIMATED_ROW_HEIGHT;\n    _this.scrollTop = 0;\n    _this.widgetHeight = 0;\n    _this.widgetWidth = 0;\n    _this.rowKeyGetter = undefined;\n    _this.rowDataGetter = getRowDataInitial;\n    _this.rowsContainerNode = null;\n    _this.scrollContainerNode = null;\n    _this.increaseEndIndexIfNeeded = debounce(function () {\n      var currentVisibleDist = _this.getDistanceBetweenIndexes(_this.startIndex, _this.endIndex);\n\n      if (_this.widgetHeight > _this.virtualTopOffset + currentVisibleDist - _this.scrollTop) {\n        _this.updateEndIndex();\n      }\n\n      return _assertThisInitialized(_this);\n    }, END_INDEX_CHECK_INTERVAL);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var absentMethods = [\"updateWidgetScrollHeight\", \"getDistanceBetweenIndexes\", \"getVisibleRangeStart\"].filter(function (fn) {\n        return !_this[fn];\n      });\n\n      if (absentMethods.length) {\n        throw new Error(\"Absent methods: \" + absentMethods.join(\",\"));\n      }\n    }\n\n    _this.on(\"#totalRows\", _this.updateWidgetScrollHeight).on(\"#totalRows\", _this.updateEndIndex).on(\"#widgetScrollHeight\", _this.increaseEndIndexIfNeeded).on(\"#endIndex\", _this.increaseEndIndexIfNeeded.cancel).on(\"#scrollTop\", _this.updateStartOffset).on(\"#overscanRowsCount\", _this.updateStartOffset).on(\"#widgetHeight\", _this.updateEndIndex).on(\"#startIndex\", _this.updateEndIndex);\n\n    return _this;\n  }\n  /*\n      Column heights may change during scroll/width-change\n  */\n\n\n  _proto.destructor = function destructor() {\n    this.increaseEndIndexIfNeeded.cancel();\n    this.removeAllListeners();\n  };\n\n  _proto.reportRowsRendered = function reportRowsRendered() {\n    this.emit(\"rows-rendered\");\n  };\n\n  _proto.updateStartOffset = function updateStartOffset() {\n    var scrollTop = this.scrollTop,\n        overscanRowsCount = this.overscanRowsCount;\n\n    var _this$getVisibleRange = this.getVisibleRangeStart(scrollTop),\n        newVisibleStartIndex = _this$getVisibleRange[0],\n        remainder = _this$getVisibleRange[1];\n\n    var newStartIndex = Math.max(0, newVisibleStartIndex - overscanRowsCount);\n    var overscanOffset = this.getDistanceBetweenIndexes(newStartIndex, newVisibleStartIndex);\n    return this.set(\"virtualTopOffset\", scrollTop - remainder - overscanOffset).set(\"startIndex\", newStartIndex);\n  };\n\n  _proto.updateEndIndex = function updateEndIndex() {\n    var _this$getVisibleRange2 = this.getVisibleRangeStart(this.scrollTop + this.widgetHeight),\n        newEndIndex = _this$getVisibleRange2[0];\n    /*\n        getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n        but for endIndex we need \"<=\", so adding 1 artificially.\n    */\n\n\n    return this.set(\"endIndex\", Math.min(newEndIndex + 1 + this.overscanRowsCount, this.totalRows));\n  };\n\n  _proto.scrollToRow = function scrollToRow(index) {\n    var node = this.scrollContainerNode;\n\n    if (node) {\n      index = clamp(index, 0, this.totalRows);\n      node.scrollTop = this.getDistanceBetweenIndexes(0, index);\n    }\n\n    return this;\n  };\n\n  _proto.scrollToStart = function scrollToStart() {\n    return this.scrollToRow(0);\n  };\n\n  return ListBase;\n}(EventEmitter);\n\n;\nexport default ListBase;","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nvar reducer = function reducer(x) {\n  return x + 1;\n};\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\n\nvar useApi = function useApi(subscribeEvents) {\n  var API = useContext(Context);\n\n  var _useReducer = useReducer(reducer, 0),\n      up = _useReducer[1];\n\n  useLayoutEffect(function () {\n    for (var j = 0; j < subscribeEvents.length; j++) {\n      API.on(subscribeEvents[j], up);\n    }\n\n    return function () {\n      for (var _j = 0; _j < subscribeEvents.length; _j++) {\n        API.off(subscribeEvents[_j], up);\n      }\n    };\n  }, subscribeEvents);\n  return API;\n};\n\nexport default useApi;","var cx = function cx(baseClass, extraClass) {\n  return extraClass ? baseClass + \" \" + extraClass : baseClass;\n};\n\nexport default cx;","var getPropsGetter = function getPropsGetter(propName) {\n  return function (data, index, getExtraProps) {\n    var _props;\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    var props = (_props = {}, _props[propName] = index + 1, _props);\n\n    if (getExtraProps) {\n      var extraProps = getExtraProps(data, index);\n\n      if (extraProps) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (extraProps.hasOwnProperty(propName)) {\n            throw new Error(\"getExtraProps must not override \" + propName);\n          }\n        }\n\n        Object.assign(props, extraProps);\n      }\n    }\n\n    return props;\n  };\n};\n\nexport var getRowProps = getPropsGetter(\"aria-rowindex\");\nexport var getCellProps = getPropsGetter(\"aria-colindex\");","import { createContext } from \"react\";\nexport default createContext();","import React, { cloneElement, memo } from \"react\";\nimport useApi from \"../useApi\";\nvar SUBSCRIBE_EVENTS = [\"#widgetScrollHeight\"];\nvar el = /*#__PURE__*/React.createElement(\"div\", {\n  \"aria-hidden\": \"true\",\n  className: \"afvscr-height-provider\"\n});\n\nvar HeightProvider = function HeightProvider() {\n  var _useApi = useApi(SUBSCRIBE_EVENTS),\n      height = _useApi.widgetScrollHeight;\n\n  var props = {\n    style: {\n      height: height\n    }\n  };\n  return cloneElement(el, props);\n};\n\nexport default memo(HeightProvider);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { forwardRef, useCallback } from \"react\";\nimport useResizeObserver from \"use-resize-observer\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\nvar SUBSCRIBE_EVENTS = [];\nvar ScrollContainer = forwardRef(function (_ref, ref) {\n  var className = _ref.className,\n      children = _ref.children,\n      onScroll = _ref.onScroll,\n      reportScrollLeft = _ref.reportScrollLeft,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\", \"children\", \"onScroll\", \"reportScrollLeft\"]);\n\n  var API = useApi(SUBSCRIBE_EVENTS);\n  var scrollHandler = useCallback(function (e) {\n    var _e$target = e.target,\n        scrollTop = _e$target.scrollTop,\n        scrollLeft = _e$target.scrollLeft;\n    API.set(\"scrollTop\", scrollTop);\n\n    if (reportScrollLeft) {\n      API.set(\"scrollLeft\", scrollLeft);\n    }\n\n    if (onScroll) {\n      onScroll(e);\n    }\n  }, [onScroll, reportScrollLeft]);\n  var resizeHandler = useCallback(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    API.set(\"widgetHeight\", height).set(\"widgetWidth\", width);\n  }, []);\n  useResizeObserver({\n    ref: ref,\n    onResize: resizeHandler\n  });\n  /*\n      tabIndex=\"0\" is for proper keyboard nav\n      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n  */\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    tabIndex: \"0\",\n    className: cx(\"afvscr-scroll-container\", className),\n    ref: ref,\n    onScroll: scrollHandler\n  }, props), /*#__PURE__*/React.createElement(HeightProvider, null), children);\n});\nexport default ScrollContainer;","import { useRef, useEffect } from \"react\";\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\n\nvar useStore = function useStore(StoreConstructor, dataRef) {\n  var finalDataRef = useRef();\n  var Store = finalDataRef.current;\n\n  if (!Store || !(Store instanceof StoreConstructor)) {\n    Store = finalDataRef.current = new StoreConstructor();\n  }\n\n  if (dataRef) {\n    dataRef.current = Store;\n  }\n\n  useEffect(function () {\n    return function () {\n      Store.destructor();\n    };\n  }, [Store]);\n  return Store;\n};\n\nexport default useStore;","import _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport ListBase from \"./ListBase\";\n\nvar FixedSizeList = /*#__PURE__*/function (_ListBase) {\n  _inheritsLoose(FixedSizeList, _ListBase);\n\n  var _super = _createSuper(FixedSizeList);\n\n  var _proto = FixedSizeList.prototype;\n\n  _proto.updateWidgetScrollHeight = function updateWidgetScrollHeight() {\n    return this.set(\"widgetScrollHeight\", this.estimatedRowHeight * this.totalRows);\n  };\n\n  _proto.updateEstimatedRowHeight = function updateEstimatedRowHeight() {\n    var node = this.rowsContainerNode;\n\n    if (node) {\n      var firstElementChild = node.firstElementChild;\n\n      if (firstElementChild) {\n        this.set(\"estimatedRowHeight\", node.firstElementChild.offsetHeight);\n      }\n    }\n  };\n\n  _proto.getVisibleRangeStart = function getVisibleRangeStart(distance) {\n    var estimatedRowHeight = this.estimatedRowHeight;\n    return [distance / estimatedRowHeight | 0, distance % estimatedRowHeight];\n  };\n\n  function FixedSizeList() {\n    var _this;\n\n    _this = _ListBase.call(this) || this;\n\n    _this.on(\"#estimatedRowHeight\", _this.updateWidgetScrollHeight).on(\"#widgetWidth\", _this.updateEstimatedRowHeight);\n\n    return _this;\n  }\n\n  _proto.getDistanceBetweenIndexes = function getDistanceBetweenIndexes(startIndex, endIndex) {\n    return this.estimatedRowHeight * (endIndex - startIndex);\n  };\n\n  return FixedSizeList;\n}(ListBase);\n\n;\nexport default FixedSizeList;","import _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport ListBase from \"./ListBase\";\nimport debounce from \"lodash/debounce\"; // Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\n\nvar SegmentsTreeCache = Uint32Array;\n/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\n\nvar MIN_TREE_CACHE_OFFSET = 32;\nvar ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 50;\nvar ROW_MEASUREMENT_DEBOUNCE_MAXWAIT = 150;\n\nvar VariableSizeList = /*#__PURE__*/function (_ListBase) {\n  _inheritsLoose(VariableSizeList, _ListBase);\n\n  var _super = _createSuper(VariableSizeList);\n\n  var _proto = VariableSizeList.prototype;\n\n  /*\n      Two vars for non-recursive segments tree;\n      Could just make [ 0, 0 ], but want to keep type of heightsCache always of same type.\n  */\n\n  /*\n      When all row heights are different,\n      we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n      basing on what we know: heights between startIndex and endIndex.\n      Using simple average by default.\n  */\n  _proto.markResetInvisibleRowHeights = function markResetInvisibleRowHeights() {\n    this.shouldResetInvisibleRowHeights = true;\n  };\n\n  _proto.updateWidgetScrollHeight = function updateWidgetScrollHeight() {\n    /* In segments tree 1 node is always sum of all elements */\n    return this.set(\"widgetScrollHeight\", this.sTree[1]);\n  };\n\n  _proto.calculateParentsInRange = function calculateParentsInRange(startIndex, endIndex) {\n    var sTree = this.sTree,\n        N = this.N;\n\n    for (endIndex += N, startIndex += N; endIndex >>= 1;) {\n      for (var i = startIndex >>= 1; i <= endIndex; i++) {\n        sTree[i] = sTree[i << 1] + sTree[i << 1 | 1];\n      }\n    }\n\n    return this;\n  }\n  /*\n      TODO: maybe some react-like performUnitOfWork logic is needed here?\n  */\n  ;\n\n  _proto.getVisibleRangeStart = function getVisibleRangeStart(dist) {\n    var sTree = this.sTree,\n        N = this.N;\n    var nodeIndex = 1,\n        v;\n\n    while (nodeIndex < N) {\n      v = sTree[nodeIndex <<= 1];\n\n      if (dist >= v) {\n        dist -= v;\n        nodeIndex |= 1;\n      }\n    }\n\n    return [nodeIndex - N, dist];\n  };\n\n  _proto.resetCache = function resetCache() {\n    var sTree = this.sTree,\n        estimatedRowHeight = this.estimatedRowHeight,\n        N = this.N,\n        totalRows = this.totalRows;\n    sTree.fill(estimatedRowHeight, N, N + totalRows);\n    /*\n        Trees are not always ideally allocated, gaps are possible.\n        Classical way for calculating parents is much simpler,\n        but can do much more work(summing zeros) in such conditions. Commented classic algo:\n             for( let i = N + totalRows >> 1, j; i > 0; --i ){\n            j = i << 1;\n            sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n        }\n    */\n\n    return this.calculateParentsInRange(0, totalRows);\n  };\n\n  _proto.reallocateCacheIfNeeded = function reallocateCacheIfNeeded() {\n    var suggestedN = this.totalRows ? Math.pow(2, Math.ceil(Math.log2(this.totalRows + MIN_TREE_CACHE_OFFSET))) : 1;\n\n    if (this.N !== suggestedN) {\n      this.N = suggestedN;\n      this.sTree = new SegmentsTreeCache(suggestedN * 2);\n    }\n\n    return this;\n  };\n\n  function VariableSizeList() {\n    var _this;\n\n    _this = _ListBase.call(this) || this;\n    _this.sTree = new SegmentsTreeCache(2);\n    _this.N = 1;\n    _this.shouldResetInvisibleRowHeights = true;\n    _this.setVisibleRowsHeights = debounce(function () {\n      var node = _this.rowsContainerNode;\n\n      if (node) {\n        var _assertThisInitialize = _assertThisInitialized(_this),\n            sTree = _assertThisInitialize.sTree,\n            N = _assertThisInitialize.N;\n\n        var l = -1,\n            r = -1,\n            rowHeightsSum = 0,\n            rowCounter = 0;\n        /*\n            Some benchmarks inspire me to use nextElementSibling\n            https://jsperf.com/nextsibling-vs-childnodes-increment/2\n        */\n\n        for (var child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++) {\n          /*\n              * aria-rowindex is counted from 1 according to w3c spec;\n              * parseInt with radix is 2x faster, then +, -, etc.\n                https://jsperf.com/number-vs-parseint-vs-plus/116\n          */\n          index = parseInt(child.getAttribute(\"aria-rowindex\"), 10) - 1;\n\n          if (process.env.NODE_ENV !== \"production\" && Number.isNaN(index)) {\n            throw new Error(\"aria-rowindex attribute must be present on each row. Look at default Row implementations.\");\n          }\n\n          newHeight = child.offsetHeight;\n          rowHeightsSum += newHeight;\n\n          if (sTree[N + index] !== newHeight) {\n            // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n            sTree[N + index] = newHeight;\n\n            if (l === -1) {\n              l = index;\n            }\n\n            r = index;\n          }\n        }\n\n        if (l !== -1) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.log(\"Updating heights in range: %d - %d\", l, r);\n          }\n\n          if (_this.shouldResetInvisibleRowHeights) {\n            _this.set(\"estimatedRowHeight\", Math.round(rowHeightsSum / rowCounter));\n\n            _this.shouldResetInvisibleRowHeights = false;\n          } else {\n            _this.calculateParentsInRange(l, r).updateWidgetScrollHeight();\n          }\n        }\n      }\n\n      return _assertThisInitialized(_this);\n    }, ROW_MEASUREMENT_DEBOUNCE_INTERVAL, {\n      maxWait: ROW_MEASUREMENT_DEBOUNCE_MAXWAIT\n    });\n\n    _this.prependListener(\"#totalRows\", _this.resetCache).prependListener(\"#totalRows\", _this.reallocateCacheIfNeeded).on(\"#estimatedRowHeight\", _this.resetCache).on(\"#estimatedRowHeight\", _this.updateWidgetScrollHeight).on(\"rows-rendered\", _this.setVisibleRowsHeights).on(\"#widgetWidth\", _this.markResetInvisibleRowHeights).on(\"#widgetWidth\", _this.setVisibleRowsHeights);\n\n    return _this;\n  }\n\n  _proto.destructor = function destructor() {\n    this.setVisibleRowsHeights.cancel();\n\n    _ListBase.prototype.destructor.call(this);\n  };\n\n  _proto.getDistanceBetweenIndexes = function getDistanceBetweenIndexes(startIndex, endIndex) {\n    var sTree = this.sTree,\n        N = this.N;\n    var res = 0;\n\n    for (startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1) {\n      if (startIndex & 1) {\n        res += sTree[startIndex++];\n      }\n\n      if (endIndex & 1) {\n        res += sTree[--endIndex];\n      }\n    }\n\n    ;\n    return res;\n  };\n\n  return VariableSizeList;\n}(ListBase);\n\n;\nexport default VariableSizeList;","import React, { memo } from \"react\";\nimport useApiPlugin from \"../useApi\";\nvar SUBSCRIBE_EVENTS = [\"#virtualTopOffset\"];\n\nvar Scroller = function Scroller(_ref) {\n  var Component = _ref.Component;\n\n  var _useApiPlugin = useApiPlugin(SUBSCRIBE_EVENTS),\n      virtualTopOffset = _useApiPlugin.virtualTopOffset;\n  /*\n      Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n  */\n\n\n  return /*#__PURE__*/React.createElement(Component, {\n    className: \"afvscr-scroller\",\n    \"aria-hidden\": \"true\",\n    style: {\n      height: virtualTopOffset\n    }\n  });\n};\n\nexport default memo(Scroller);","var commonDefaultProps = {\n  fixedSize: false,\n  rowCount: 0,\n  overscanRowsCount: 4\n};\nexport default commonDefaultProps;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from \"react\";\nimport cx from \"../utils/cx\";\n\nvar RowCountWarningContainer = function RowCountWarningContainer(_ref) {\n  var className = _ref.className,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\"]);\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    className: cx(\"afvscr-row-count-warning-container\", className)\n  }, props));\n};\n\nexport default RowCountWarningContainer;"],"sourceRoot":""}