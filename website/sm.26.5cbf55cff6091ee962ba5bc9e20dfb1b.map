{"version":3,"sources":["webpack:///./src/utils/isPositionStickySupported/index.js","webpack:///./src/Context.js","webpack:///./src/utils/useStore/index.js","webpack:///./src/models/createTable.js","webpack:///./src/models/ListBase.js","webpack:///./src/models/FixedSizeTable.js","webpack:///./src/models/FixedSizeList.js","webpack:///./src/models/VariableSizeList.js","webpack:///./src/models/VariableSizeTable.js","webpack:///./src/utils/extraPropsGetters/index.js","webpack:///./src/Table/common/Row.js","webpack:///./src/Table/common/Cell.js","webpack:///./src/Table/common/TotalsCell.js","webpack:///./src/utils/cx/index.js","webpack:///./src/common/RowCountWarningContainer.js","webpack:///./src/useApi/index.js","webpack:///./src/Table/common/Colgroup.js","webpack:///./src/Table/NonSticky/TableWrapper/index.js","webpack:///./src/Table/common/HeaderCells.js","webpack:///./src/Table/common/Thead.js","webpack:///./src/Table/common/FooterCells.js","webpack:///./src/Table/common/Tfoot.js","webpack:///./src/Table/common/Rows.js","webpack:///./src/Table/common/Tbody.js","webpack:///./src/Table/common/BodyTable.js","webpack:///./src/Table/NonSticky/useColWidthsResizeObserver/index.js","webpack:///./src/common/Scroller.js","webpack:///./src/Table/common/TbodyScroller.js","webpack:///./src/common/HeightProvider.js","webpack:///./src/common/ScrollContainer.js","webpack:///./src/Table/NonSticky/index.js","webpack:///./src/Table/Sticky/index.js","webpack:///./src/commonDefaultProps.js","webpack:///./src/Table/index.js","webpack:///./websiteSrc/examples/table/variableRowHeights.js"],"names":["stickyCssText","map","p","join","once","elStyle","document","createElement","style","cssText","position","includes","createContext","useStore","StoreConstructor","dataRef","finalDataRef","useRef","Store","current","useEffect","destructor","OrderedRowsCache","Uint32Array","TbodyColumnWidthsCache","L","Intl","Collator","getValueForSorting","srcVal","rowIndex","fieldName","defaultValue","getRowData","getCellData","result","reduceRange","totalRows","dataKey","startValue","getNewRes","rowData","res","i","TotalsCachePart","count","sum","average","createTable","BaseClass","constructorCallback","columns","totals","headlessMode","sortColumnIndex","sortDirectionSign","scrollLeft","tbodyColumnWidths","orderedRows","totalsCache","Object","create","refreshTotals","debounce","j","length","refreshTotalsForColumnRaw","refreshSorting","sort","sorter","method","directionSign","fn","compare","subtract","a","b","v1","v2","getSorter","rowDataGetter","emit","on","resetColumnWidthsCache","refreshRowsOrder","scrollToStart","cellDataGetter","curTotals","this","curCachePart","totalType","oldVal","newVal","tmpSum","undefined","add","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Math","process","refreshTotalsForColumn","col","find","c","setSortParams","colIndex","rows","cancel","getRowDataInitial","Error","ListBase","startIndex","endIndex","virtualTopOffset","widgetScrollHeight","overscanRowsCount","estimatedRowHeight","scrollTop","widgetHeight","widgetWidth","rowKeyGetter","rowsContainerNode","scrollContainerNode","increaseEndIndexIfNeeded","currentVisibleDist","getDistanceBetweenIndexes","updateEndIndex","updateWidgetScrollHeight","updateStartOffset","set","paramName","paramValue","merge","params","k","removeAllListeners","reportRowsRendered","getVisibleRangeStart","newVisibleStartIndex","remainder","newStartIndex","max","overscanOffset","newEndIndex","min","scrollToRow","index","node","clamp","EventEmitter","updateEstimatedRowHeight","firstElementChild","offsetHeight","distance","SegmentsTreeCache","sTree","N","shouldResetInvisibleRowHeights","setVisibleRowsHeights","newHeight","l","r","rowHeightsSum","rowCounter","child","nextElementSibling","parseInt","getAttribute","round","calculateParentsInRange","maxWait","prependListener","resetCache","reallocateCacheIfNeeded","markResetInvisibleRowHeights","dist","v","nodeIndex","fill","suggestedN","ceil","log2","instance","getPropsGetter","propName","data","getExtraProps","props","extraProps","assign","getRowProps","getCellProps","Row","CellComponent","getRowExtraProps","getCellExtraProps","rowDataIndex","column","columnIndex","visibility","FinalCellComponent","key","propTypes","Cell","render","getEmptyCellData","format","cellData","TotalsCell","cellTotals","formatTotal","summaryType","title","capitalize","cx","baseClass","extraClass","RowCountWarningContainer","className","reducer","x","useApi","subscribeEvents","API","useContext","Context","up","useReducer","useLayoutEffect","off","commonSubscribeEvents","nonStickySubscribeEvents","concat","memo","useTbodyWidths","useApiPlugin","cols","background","border","width","SUBSCRIBE_EVENTS","TableWrapper","children","marginLeft","aria-colcount","SortDirections","label","data-sortable","aria-colindex","aria-sort","trRef","getCellStyle","clickHandler","useCallback","e","target","onClick","ref","FooterCells","TotalsCellComponent","curTotalsCache","Rows","RowComponent","rangeFrom","rangeTo","getRowKey","rowKey","idx","push","getVisibleRows","tbodyRef","BodyTable","fixedLayout","tableStyle","tableLayout","minWidth","aria-rowcount","useColWidthsResizeObserver","observerRef","O","ResizeObserver","entries","contentRect","observe","disconnect","Component","aria-hidden","height","TbodyScroller","el","cloneElement","ScrollContainer","forwardRef","onScroll","reportScrollLeft","scrollHandler","R","unobserve","tabIndex","scrollContainerRef","widthsObserverRef","useMemo","commonDefaultProps","fixedSize","rowCount","Table","rowCountWarningsTable","headless","useStickyIfPossible","FixedSizeTableStore","VariableSizeTableStore","ComponentVariant","isPositionStickySupported","StickyComponent","NonStickyComponent","Provider","value","defaultProps","RowComponentDefault","CellComponentDefault","TotalsCellComponentDefault","RowCountWarningContainerDefault","tableCss","lineHeight","times","num","str","faker","name","findName","rect","VariableRowHeightsTable","css"],"mappings":"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","file":"26.a4be157c4c5bce9c0483.js","sourcesContent":["import once from \"lodash/once\";\n\nconst stickyCssText = [ \"\", \"-webkit-\", \"-ms-\" ].map( p => `position:${p}sticky` ).join( \";\" );\n\nconst isPositionStickySupported = () => {\n    const elStyle = document.createElement( \"a\" ).style;\n    elStyle.cssText = stickyCssText;\n    \n    return elStyle.position.includes( \"sticky\" );\n};\n\n/*\n    'once' is needed to use this function frequently without perf issues.\n*/\nexport default once( isPositionStickySupported );","import { createContext } from \"react\";\n\nexport default createContext();","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef ) => {\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !Store || !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    useEffect(() => () => {\n        Store.destructor();\n    }, [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","import debounce from \"lodash/debounce\";\nimport subtract from \"lodash/subtract\";\nimport add from \"lodash/add\";\n\nconst OrderedRowsCache = Uint32Array;\nconst TbodyColumnWidthsCache = Uint32Array;\n\nconst REFRESH_SORT_DEBOUNCE_INTERVAL = 500;\n\nconst L = new Intl.Collator();\n\nconst getValueForSorting = ( srcVal, rowIndex, fieldName, defaultValue, getRowData, getCellData ) => {\n    const result = getRowData( srcVal );\n    if( result ){\n        return getCellData ? getCellData( result, rowIndex ) : result[ fieldName ];\n    }\n    return defaultValue;\n}\n\nconst getSorter = ( getRowData, fieldName, method, getCellData, directionSign ) => {\n    const fn = method === \"locale\" ? L.compare : subtract;\n    const defaultValue = method === \"locale\" ? \"\" : 0;\n\n    return ( a, b, i ) => {\n        const v1 = getValueForSorting( a, i, fieldName, defaultValue, getRowData, getCellData );\n        const v2 = getValueForSorting( b, i, fieldName, defaultValue, getRowData, getCellData );\n        return fn( v1, v2 ) * directionSign;\n    };\n};\n\nconst reduceRange = ( totalRows, dataKey, getRowData, getCellData, startValue, getNewRes ) => {\n    let res = startValue;\n    for( let i = 0, rowData, cellData; i < totalRows; i++ ){\n        rowData = getRowData( i );\n        cellData = getCellData ? getCellData( rowData, i ) : rowData[ dataKey ];\n        res = getNewRes( res, cellData );\n    }\n    return res;\n}\n\n/*\n    We could use simple object literal,\n    but constructors with stable-order this initialization enforce \"hidden-classes\" v8 optimization\n*/\nclass TotalsCachePart {\n    count = 0;\n    sum = 0;\n    average = 0.0;\n};\n\n/*\n    can't extend from both FixedSizeList and VariableSizeList, so exporting compositor\n*/\nconst createTable = ( BaseClass, constructorCallback ) => class extends BaseClass {\n\n    columns = [];\n    totals = {};\n    headlessMode = false;\n\n    sortColumnIndex = -1;\n    sortDirectionSign = 1;\n\n    scrollLeft = 0;\n    tbodyColumnWidths = null;\n    orderedRows = new OrderedRowsCache( 0 );\n\n    /*\n        We do not want to recalculate totals too often, so caching them in object by column dataKey\n    */\n    totalsCache = Object.create( null );\n\n\n    /*\n        TODO:\n            make this call throttled\n    */\n\n    refreshTotalsForColumnRaw( dataKey, cellDataGetter ){\n        const curTotals = this.totals && this.totals[ dataKey ];\n        if( curTotals ){\n            let curCachePart = this.totalsCache[ dataKey ];\n\n            if( !curCachePart ){\n                curCachePart = this.totalsCache[ dataKey ] = new TotalsCachePart();\n            }\n            \n            for( let j = 0, totalType, oldVal, newVal, tmpSum; j < curTotals.length; j++ ){\n                totalType = curTotals[ j ];\n                oldVal = curCachePart[ totalType ];\n                switch( totalType ){\n                    case \"count\":\n                        newVal = this.totalRows;\n                        break;\n                    case \"sum\":\n                    case \"average\":\n                        if( tmpSum === undefined ){\n                            tmpSum = reduceRange( this.totalRows, dataKey, this.rowDataGetter, cellDataGetter, 0, add );\n                        }\n                        newVal = totalType === \"sum\" ? tmpSum : tmpSum / this.totalRows;\n                        break;\n                    case \"min\":\n                    case \"max\":\n                        newVal = reduceRange(\n                            this.totalRows,\n                            dataKey,\n                            this.rowDataGetter,\n                            cellDataGetter,\n                            totalType === \"min\" ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER,\n                            Math[totalType]\n                        );\n                        break;\n                    default:\n                        if( process.env.NODE_ENV !== \"production\" ){\n                            throw new Error( `Wrong total type: ${totalType}` );\n                        }\n                }\n  \n                if( oldVal !== newVal ){\n                    curCachePart[ totalType ] = newVal;\n                    this.emit( \"totals-calculated\" );\n                }\n            }\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.log( `Asked to recalculate totals for: ${dataKey}; doing nothing;` );\n        }\n        return this;\n    }\n\n    refreshTotalsForColumn( dataKey ){\n        const col = this.columns.find( c => c.dataKey === dataKey );\n        if( col ){\n            this.refreshTotalsForColumnRaw( dataKey, col.getCellData );\n        }\n        return this;\n    }\n\n    refreshTotals = debounce(() => {\n        for( let j = 0, dataKey, getCellData; j < this.columns.length; j++ ){\n            ({ dataKey, getCellData } = this.columns[ j ]);\n            this.refreshTotalsForColumnRaw( dataKey, getCellData );\n        }\n        return this;\n    }, 100 );\n\n    setSortParams( colIndex, sortDirectionSign ){\n        if( this.sortColumnIndex !== colIndex || sortDirectionSign !== this.sortDirectionSign ){\n            this.sortColumnIndex = colIndex;\n            this.sortDirectionSign = sortDirectionSign;\n            this.emit( \"sort-params-changed\" );\n        }\n    }\n\n    refreshSorting = debounce(() => {\n        if( this.sortColumnIndex > -1 && this.totalRows > 0 ){\n            const { sort, dataKey, getCellData } = this.columns[ this.sortColumnIndex ];\n            if( sort ){\n                const sorter = getSorter( this.rowDataGetter, dataKey, sort, getCellData, this.sortDirectionSign );\n                this.orderedRows.sort( sorter );\n                this.emit( \"#rowsOrder\" );\n            }\n        }\n    }, REFRESH_SORT_DEBOUNCE_INTERVAL );\n\n    refreshRowsOrder(){\n        if( this.orderedRows.length !== this.totalRows ){\n            const rows = this.orderedRows = new OrderedRowsCache( this.totalRows );\n            for( let j = 1; j < rows.length; j++ ){\n                rows[ j ] = j;\n            }\n        }\n        return this;\n    }\n\n    resetColumnWidthsCache(){\n        this.tbodyColumnWidths = new TbodyColumnWidthsCache( this.columns.length );\n    }\n\n    constructor(){\n        super();\n\n        this\n            .on( \"#columns\", this.resetColumnWidthsCache )\n            .on( \"#columns\", this.refreshTotals )\n            .on( \"#columns\", this.refreshSorting )\n            .on( \"#totalRows\", this.refreshRowsOrder )\n            .on( \"#totalRows\", this.refreshSorting )\n            .on( \"#totalRows\", this.refreshTotals )\n            .on( \"sort-params-changed\", this.refreshSorting )\n            .on( \"#rowDataGetter\", this.refreshSorting )\n            .on( \"#rowDataGetter\", this.refreshTotals )\n            .on( \"#rowsOrder\", this.scrollToStart )\n            .on( \"#totals\", this.refreshTotals )\n        \n            .refreshRowsOrder();\n\n        if( constructorCallback ){\n            constructorCallback( this );\n        }\n    }\n\n    destructor(){\n        this.refreshSorting.cancel();\n        this.refreshTotals.cancel();\n        super.destructor();\n    }\n}\n\nexport default createTable;","import clamp from \"lodash/clamp\";\nimport EventEmitter from \"af-tools/lib/eventEmitters/Basic\";\nimport debounce from \"lodash/debounce\";\n\nconst getRowDataInitial = () => {\n    throw new Error( \"getRowData must be provided\" );\n};\n\nconst END_INDEX_CHECK_INTERVAL = 400;\nconst DEFAULT_ESTIMATED_ROW_HEIGHT = 16;\n\nclass ListBase extends EventEmitter {\n\n    totalRows = 0;\n    startIndex = 0;\n    endIndex = 0;\n\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n\n    overscanRowsCount = 0;\n    estimatedRowHeight = DEFAULT_ESTIMATED_ROW_HEIGHT;\n\n    scrollTop = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n\n    rowKeyGetter = undefined;\n    rowDataGetter = getRowDataInitial;\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    set( paramName, paramValue ){\n\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.hasOwnProperty( paramName ) ){\n                throw new Error( `Trying to merge key, which does not exist: ${paramName}` );\n            }\n        }\n\n        if( this[ paramName ] !== paramValue ){\n            this[ paramName ] = paramValue;\n            this.emit( `#${paramName}` );\n        }\n\n        return this;\n    }\n    \n    merge( params ){\n        for( let k in params ){\n            this.set( k, params[ k ] );\n        }\n        return this;\n    }\n    \n    constructor(){\n        super();\n        \n        if( process.env.NODE_ENV !== \"production\" ){\n            const absentMethods = [\n                \"updateWidgetScrollHeight\",\n                \"getDistanceBetweenIndexes\",\n                \"getVisibleRangeStart\"\n            ].filter( fn => !this[ fn ] );\n\n            if( absentMethods.length ){\n                throw new Error( `Absent methods: ${absentMethods.join( \",\" )}` );\n            }\n        }\n\n        this\n            .on( \"#totalRows\", this.updateWidgetScrollHeight )\n            .on( \"#totalRows\", this.updateEndIndex )\n            .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\n            .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel )\n            .on( \"#scrollTop\", this.updateStartOffset )\n            .on( \"#overscanRowsCount\", this.updateStartOffset )\n            .on( \"#widgetHeight\", this.updateEndIndex )\n            .on( \"#startIndex\", this.updateEndIndex );\n    }\n\n    /*\n        Column heights may change during scroll/width-change\n    */\n    increaseEndIndexIfNeeded = debounce(() => {\n        const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n        return this;\n    }, END_INDEX_CHECK_INTERVAL );\n\n    destructor(){\n        this.increaseEndIndexIfNeeded.cancel();\n        this.removeAllListeners();\n    }\n    \n    reportRowsRendered(){\n        this.emit( \"rows-rendered\" );\n    }\n\n    updateStartOffset(){\n        const { scrollTop, overscanRowsCount } = this;\n        const [ newVisibleStartIndex, remainder ] = this.getVisibleRangeStart( scrollTop );\n        const newStartIndex = Math.max( 0, newVisibleStartIndex - overscanRowsCount );\n        const overscanOffset = this.getDistanceBetweenIndexes( newStartIndex, newVisibleStartIndex );\n                \n        return this\n            .set( \"virtualTopOffset\", scrollTop - remainder - overscanOffset )\n            .set( \"startIndex\", newStartIndex );\n    }\n\n    updateEndIndex(){\n        const [ newEndIndex ] = this.getVisibleRangeStart( this.scrollTop + this.widgetHeight );\n        /*\n            getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return this.set( \"endIndex\", Math.min( newEndIndex + 1 + this.overscanRowsCount, this.totalRows ) );\n    }\n\n    scrollToRow( index ){\n        const node = this.scrollContainerNode;\n        if( node ){\n            index = clamp( index, 0, this.totalRows );\n            node.scrollTop = this.getDistanceBetweenIndexes( 0, index );\n        }\n        return this;    \n    }\n\n    scrollToStart(){\n        return this.scrollToRow( 0 );\n    }\n};\n\nexport default ListBase;","import createTable from \"./createTable\";\nimport FixedSizeList from \"./FixedSizeList\";\n\nexport default createTable( FixedSizeList );","import ListBase from \"./ListBase\";\n\nclass FixedSizeList extends ListBase {\n    \n    updateWidgetScrollHeight(){\n        return this.set( \"widgetScrollHeight\", this.estimatedRowHeight * this.totalRows );\n    }\n\n    updateEstimatedRowHeight(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { firstElementChild } = node;\n            if( firstElementChild ){\n                this.set( \"estimatedRowHeight\", node.firstElementChild.offsetHeight );\n            }\n        }\n    }\n\n    getVisibleRangeStart( distance ){\n        const { estimatedRowHeight } = this;\n        return [ distance / estimatedRowHeight | 0, distance % estimatedRowHeight ];\n    }\n\n    constructor(){\n        super();\n\n        this\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"#widgetWidth\", this.updateEstimatedRowHeight );\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        return this.estimatedRowHeight * ( endIndex - startIndex );\n    }\n};\n\nexport default FixedSizeList;","import ListBase from \"./ListBase\";\nimport debounce from \"lodash/debounce\";\n\n// Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\nconst SegmentsTreeCache = Uint32Array;\n\n/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_OFFSET = 32;\n\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 50;\nconst ROW_MEASUREMENT_DEBOUNCE_MAXWAIT = 150; \n\nclass VariableSizeList extends ListBase {\n\n    /*\n        Two vars for non-recursive segments tree;\n        Could just make [ 0, 0 ], but want to keep type of heightsCache always of same type.\n    */\n    sTree = new SegmentsTreeCache( 2 );\n    N = 1;\n\n    /*\n        When all row heights are different,\n        we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n        basing on what we know: heights between startIndex and endIndex.\n        Using simple average by default.\n    */\n    shouldResetInvisibleRowHeights = true;\n\n    markResetInvisibleRowHeights(){\n        this.shouldResetInvisibleRowHeights = true;\n    }\n\n    updateWidgetScrollHeight(){\n        /* In segments tree 1 node is always sum of all elements */\n        return this.set( \"widgetScrollHeight\", this.sTree[ 1 ] );\n    }\n\n    calculateParentsInRange( startIndex, endIndex ){\n        const { sTree, N } = this;\n    \n        for( endIndex += N, startIndex += N; endIndex >>= 1; ){\n            for( let i = startIndex >>= 1; i <= endIndex; i++ ){\n                sTree[ i ] = sTree[ i << 1 ] + sTree[ i << 1 | 1 ];\n            }\n        }\n\n        return this;\n    }\n\n    /*\n        TODO: maybe some react-like performUnitOfWork logic is needed here?\n    */\n    setVisibleRowsHeights = debounce(() => {\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { sTree, N } = this;\n            \n            let l = -1,\n                r = -1,\n                rowHeightsSum = 0,\n                rowCounter = 0;\n\n            /*\n                Some benchmarks inspire me to use nextElementSibling\n                https://jsperf.com/nextsibling-vs-childnodes-increment/2\n            */\n            for( let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++ ){\n                \n                /*\n                    * aria-rowindex is counted from 1 according to w3c spec;\n                    * parseInt with radix is 2x faster, then +, -, etc.\n                      https://jsperf.com/number-vs-parseint-vs-plus/116\n                */\n                index = parseInt( child.getAttribute( \"aria-rowindex\" ), 10 ) - 1;\n\n                if( process.env.NODE_ENV !== \"production\" && Number.isNaN( index ) ){\n                    throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                }\n\n                newHeight = child.offsetHeight;\n                rowHeightsSum += newHeight;\n\n                if( sTree[ N + index ] !== newHeight ){\n                    // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n                    sTree[ N + index ] = newHeight;\n                    \n                    if( l === -1 ){\n                        l = index;\n                    }\n                    \n                    r = index;\n                }\n            }\n \n            if( l !== -1 ){\n                if( process.env.NODE_ENV !== \"production\" ){\n                    console.log( \"Updating heights in range: %d - %d\", l, r );\n                }\n\n                if( this.shouldResetInvisibleRowHeights ){\n                    this.set( \"estimatedRowHeight\", Math.round( rowHeightsSum / rowCounter ) );\n                    this.shouldResetInvisibleRowHeights = false;\n                }\n                else{\n                    this\n                        .calculateParentsInRange( l, r )\n                        .updateWidgetScrollHeight();\n                }\n            }\n        }\n\n        return this;\n    }, ROW_MEASUREMENT_DEBOUNCE_INTERVAL, { maxWait: ROW_MEASUREMENT_DEBOUNCE_MAXWAIT });\n    \n    getVisibleRangeStart( dist ){\n        const { sTree, N } = this;\n        let nodeIndex = 1, v;\n\n        while( nodeIndex < N ){\n            v = sTree[ nodeIndex <<= 1 ];\n            if( dist >= v ){\n                dist -= v;\n                nodeIndex |= 1;\n            }\n        }\n\n        return [ nodeIndex - N, dist ];\n    }\n\n    resetCache(){\n        const { sTree, estimatedRowHeight, N, totalRows } = this;\n        sTree.fill( estimatedRowHeight, N, N + totalRows );\n\n        /*\n            Trees are not always ideally allocated, gaps are possible.\n            Classical way for calculating parents is much simpler,\n            but can do much more work(summing zeros) in such conditions. Commented classic algo:\n    \n            for( let i = N + totalRows >> 1, j; i > 0; --i ){\n                j = i << 1;\n                sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n            }\n        */\n        return this.calculateParentsInRange( 0, totalRows );\n    }\n\n    reallocateCacheIfNeeded(){\n        const suggestedN = this.totalRows ? 2 ** Math.ceil( Math.log2( this.totalRows + MIN_TREE_CACHE_OFFSET ) ) : 1;\n\n        if( this.N !== suggestedN ){\n            this.N = suggestedN;\n            this.sTree = new SegmentsTreeCache( suggestedN * 2 );\n        }\n\n        return this;\n    }\n\n    constructor(){\n        super();\n\n        this\n            .prependListener( \"#totalRows\", this.resetCache )\n            .prependListener( \"#totalRows\", this.reallocateCacheIfNeeded )\n            .on( \"#estimatedRowHeight\", this.resetCache )\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"rows-rendered\", this.setVisibleRowsHeights )\n            .on( \"#widgetWidth\", this.markResetInvisibleRowHeights )\n            .on( \"#widgetWidth\", this.setVisibleRowsHeights );\n    }\n\n    destructor(){\n        this.setVisibleRowsHeights.cancel();\n        super.destructor();\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        const { sTree, N } = this;\n        let res = 0;\n\n        for( startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1 ){\n            if( startIndex & 1 ){\n                res += sTree[ startIndex++ ];\n            }\n\n            if( endIndex & 1 ){\n                res += sTree[ --endIndex ]; \n            }\n        };\n\n        return res; \n    }\n};\n\nexport default VariableSizeList;","import createTable from \"./createTable\";\nimport VariableSizeList from \"./VariableSizeList\";\n\nexport default createTable( VariableSizeList, instance => {\n    instance.prependListener( \"#rowsOrder\", instance.resetCache );\n});","const getPropsGetter = propName => ( data, index, getExtraProps ) => {\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    const props = {\n        [propName]: index + 1\n    };\n\n    if( getExtraProps ){\n        const extraProps = getExtraProps( data, index );\n        if( extraProps ){\n            if( process.env.NODE_ENV !== \"production\" ){\n                if( extraProps.hasOwnProperty( propName ) ){\n                    throw new Error( `getExtraProps must not override ${propName}` );\n                }\n            }\n            Object.assign( props, extraProps );\n        }\n    }\n\n    return props;\n}\n\nexport const getRowProps = getPropsGetter( \"aria-rowindex\" );\nexport const getCellProps = getPropsGetter( \"aria-colindex\" );","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst Row = ({ columns, CellComponent, getRowData, getRowExtraProps, getCellExtraProps, rowDataIndex, rowIndex }) => {\n\n    const rowData = getRowData( rowDataIndex );\n\n    return (\n        <tr {...getRowProps(rowData,rowDataIndex,getRowExtraProps)}>\n            {columns.map(( column, columnIndex ) => {\n                if( column.visibility === \"hidden\" ){\n                    return null;\n                }\n\n                const FinalCellComponent = column.CellComponent || CellComponent;\n\n                return (\n                    <FinalCellComponent\n                        key={column.dataKey}\n                        rowData={rowData}\n                        rowIndex={rowIndex}\n                        column={column}\n                        columnIndex={columnIndex}\n                        getCellExtraProps={column.getCellExtraProps||getCellExtraProps}\n                    />\n                );\n            })}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.oneOfType([ PropTypes.func, PropTypes.node ]).isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    rowDataIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getCellProps } from \"../../utils/extraPropsGetters\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, column, columnIndex, getCellExtraProps }) => {\n    const { render, getEmptyCellData, dataKey, format, getCellData } = column;\n\n    let cellData = rowData && ( getCellData ? getCellData( rowData, rowIndex ) : rowData[ dataKey ] );\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else{\n        if( format ){\n            cellData = format( cellData, rowData );\n        }\n        if( render ){\n            cellData = render( cellData, rowData, column );\n        }\n    }\n\n    return (\n        <td {...getCellProps(rowData,columnIndex,getCellExtraProps)}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    rowIndex: PropTypes.number.isRequired,\n    columnIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Cell;","import React from \"react\";\nimport capitalize from \"lodash/capitalize\";\n\nconst TotalsCell = ({ cellTotals, totalsCache, formatTotal }) => {\n\n    if( !cellTotals || !totalsCache ){\n        return null;\n    }\n\n    if( cellTotals.length === 1 ){\n        const summaryType = cellTotals[ 0 ];\n        const res = totalsCache[ summaryType ];\n        return (\n            <div title={summaryType}>\n                {formatTotal?formatTotal(res):res}\n            </div>\n        );\n    }\n\n    return cellTotals.map( summaryType => {\n        const res = totalsCache[ summaryType ];\n        return res !== undefined ? (\n            <div key={summaryType}>\n                {capitalize(summaryType)}:&nbsp;{formatTotal?formatTotal(res):res}\n            </div>\n        ) : null;\n    });\n};\n\nexport default TotalsCell;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nexport default cx;","import React from \"react\";\nimport cx from \"../utils/cx\"\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(\"afvscr-row-count-warning-container\",className)} {...props} />;\n\nexport default RowCountWarningContainer;","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nconst reducer = x => x + 1;\n\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\nconst useApi = subscribeEvents => {\n\n\tconst API = useContext( Context );\n\n\tconst [, up] = useReducer( reducer, 0 );\n    \n\tuseLayoutEffect(() => {\n\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\tAPI.on( subscribeEvents[ j ], up );\n\t\t}\n\t\treturn () => {\n\t\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\t\tAPI.off( subscribeEvents[ j ], up );\n\t\t\t}\n\t\t};\n\t}, subscribeEvents );\n\n\treturn API;\n};\n\nexport default useApi;\n","import React, { memo } from \"react\";\nimport useApiPlugin from \"../../useApi\";\n\nconst commonSubscribeEvents = [ \"#columns\" ];\nconst nonStickySubscribeEvents = commonSubscribeEvents.concat( \"tbody-column-widths-changed\" );\n\nconst Colgroup = ({ useTbodyWidths }) => {\n\n    const { columns, tbodyColumnWidths } = useApiPlugin( useTbodyWidths ? nonStickySubscribeEvents : commonSubscribeEvents );\n\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }, j, cols ) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width: useTbodyWidths ? tbodyColumnWidths[ j ] : width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React from \"react\";\nimport sum from \"lodash/sum\";\nimport useApi from \"../../../useApi\";\nimport Colgroup from \"../../common/Colgroup\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"#scrollLeft\",\n    \"#widgetWidth\",\n    \"tbody-column-widths\"\n];\n\nconst TableWrapper = ({ children, ...props }) => {\n\n    const { scrollLeft, columns, tbodyColumnWidths } = useApi( SUBSCRIBE_EVENTS );\n\n    const style = {\n        /* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */\n        marginLeft: -scrollLeft,\n\n        /* TODO: maybe box-sizing:border-box; is needed here? */\n        width: sum( tbodyColumnWidths )\n    };\n\n    return (\n        <table {...props} style={style} aria-colcount={columns.length}>\n            <Colgroup useTbodyWidths />\n            {children}\n        </table>\n    );\n};\n\nexport default TableWrapper;","import React, { memo } from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"sort-params-changed\"\n];\n\nconst SortDirections = {\n    \"1\": \"ascending\",\n    \"-1\": \"descending\"\n};\n\nconst HeaderCells = () => {\n\n    const { columns, sortColumnIndex, sortDirectionSign } = useApi( SUBSCRIBE_EVENTS );\n\n    return columns.map(({ dataKey, title, sort, label, visibility }, j ) => visibility === \"hidden\" ? null : (\n        <th\n            key={dataKey}\n            title={title}\n            data-sortable={sort?\"\":undefined}\n            aria-colindex={j+1}\n            aria-sort={sortColumnIndex!==j?\"none\":SortDirections[sortDirectionSign]}\n        >\n            {label}\n        </th>\n    ));\n};\n\nexport default memo( HeaderCells );","import React, { useCallback, memo } from \"react\";\nimport HeaderCells from \"./HeaderCells\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [];\n\nconst Thead = ({ trRef, getCellStyle, ...props }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const clickHandler = useCallback( e => {\n\n        const colIndex = parseInt( e.target.getAttribute( \"aria-colindex\" ), 10 ) - 1;\n\n        if( process.env.NODE_ENV !== \"production\" && Number.isNaN( colIndex ) ){\n            throw new Error( \"colIndex attr missing\" );\n        }\n\n        if( API.columns[ colIndex ].sort ){\n            const directionSign = e.target.getAttribute( \"aria-sort\" ) === \"ascending\" ? -1 : 1;\n            API.setSortParams( colIndex, directionSign );\n        }\n    }, []);\n\n    return (\n        <thead {...props} onClick={clickHandler}>\n            <tr ref={trRef}>\n                <HeaderCells />\n            </tr>\n        </thead>\n    );\n};\n\nexport default memo( Thead );","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"#totals\",\n    \"totals-calculated\"\n];\n\nconst FooterCells = ({ TotalsCellComponent }) => {\n\n    const { columns, totals, totalsCache } = useApi( SUBSCRIBE_EVENTS );\n\n    return columns.map(({ dataKey, formatTotal, visibility }, j ) => {\n\n        if( visibility === \"hidden\" ){\n            return null;\n        }\n\n        const curTotals = totals[ dataKey ];\n        const curTotalsCache = totalsCache[ dataKey ];\n\n        return (\n            <td key={dataKey} aria-colindex={j+1}>\n                <TotalsCellComponent\n                    cellTotals={curTotals}\n                    totalsCache={curTotalsCache}\n                    formatTotal={formatTotal}\n                />\n            </td>\n        );\n    });\n};\n\nFooterCells.propTypes = {\n    TotalsCellComponent: PropTypes.any.isRequired\n}\n\nexport default memo( FooterCells );","import React, { memo } from \"react\";\nimport FooterCells from \"./FooterCells\";\n\nconst Tfoot = ({ className, trRef, TotalsCellComponent }) => (\n    <tfoot className={className}>\n        <tr ref={trRef}>\n            <FooterCells TotalsCellComponent={TotalsCellComponent} />\n        </tr>\n    </tfoot>\n);\n\nexport default memo( Tfoot );","import React, { useEffect } from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#startIndex\",\n    \"#endIndex\",\n    \"#columns\",\n    \"#rowsOrder\",\n    \"#rowKeyGetter\",\n    \"#rowDataGetter\"\n];\n\nconst getVisibleRows = (\n    orderedRows,\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey, idx; rangeFrom < rangeTo; rangeFrom++ ){\n        idx = orderedRows[ rangeFrom ];\n        rowKey = getRowKey ? getRowKey( idx ) : idx;\n        result.push(\n            <RowComponent\n                getRowExtraProps={getRowExtraProps}\n                getCellExtraProps={getCellExtraProps}\n                rowIndex={rangeFrom}\n                rowDataIndex={idx}\n                key={rowKey}\n                columns={columns}\n                getRowData={getRowData}\n                CellComponent={CellComponent}\n            />\n        );\n    }\n    return result;\n};\n\nconst Rows = ({ getRowExtraProps, getCellExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    useEffect(() => {\n        API.reportRowsRendered();\n    });\n\n    return getVisibleRows(\n        API.orderedRows,\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        API.rowDataGetter,\n        API.rowKeyGetter,\n        getRowExtraProps,\n        getCellExtraProps,\n        RowComponent,\n        CellComponent\n    );\n};\n\nexport default Rows;","import React, { memo } from \"react\";\nimport Rows from \"./Rows\";\n\nconst Tbody = ({\n    getRowExtraProps,\n    getCellExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent\n}) => (\n    <tbody ref={tbodyRef}>\n        <Rows\n            getRowExtraProps={getRowExtraProps}\n            getCellExtraProps={getCellExtraProps}\n            RowComponent={RowComponent}\n            CellComponent={CellComponent}\n        />\n    </tbody>\n);\n\nexport default memo( Tbody );","import React from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#totalRows\",\n    \"#columns\"\n];\n\nconst BodyTable = ({ fixedLayout, ...props }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const tableStyle = {\n        tableLayout: fixedLayout ? \"fixed\" : \"auto\",\n        minWidth: \"100%\"\n    };\n    \n    return (\n        <table\n            {...props}\n            aria-rowcount={API.totalRows}\n            style={tableStyle}\n            aria-colcount={API.columns.length}\n        />\n    );\n};\n\nexport default BodyTable;","import { useRef, useEffect } from \"react\";\n\nconst useColWidthsResizeObserver = API => {\n\n    const observerRef = useRef();\n    const trRef = useRef();\n\n    let O = observerRef.current;\n\n    if( !O ){\n        O = observerRef.current = new ResizeObserver( entries => {\n            for( let j = 0, colIndex; j < entries.length; j++ ){\n                const { target, contentRect } = entries[ j ];\n                colIndex = parseInt( target.getAttribute( \"aria-colindex\" ) );\n                API.tbodyColumnWidths[ colIndex - 1 ] = Math.round( contentRect.width );\n            }\n            API.emit( \"tbody-column-widths-changed\" );\n        });\n    }\n\n    useEffect(() => {\n        if( trRef.current ){\n            for( let node = trRef.current.firstElementChild; node; node = node.nextElementSibling ){\n                O.observe( node );\n            }\n            return () => {\n                O.disconnect();\n            };\n        }\n    }, [ trRef.current ]);\n\n    return trRef;\n};\n\nexport default useColWidthsResizeObserver;","import React, { memo } from \"react\";\nimport useApiPlugin from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#virtualTopOffset\" ];\n\nconst Scroller = ({ Component }) => {\n\n    const { virtualTopOffset } = useApiPlugin( SUBSCRIBE_EVENTS );\n    /*\n        Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n    */\n    return <Component className=\"afvscr-scroller\" aria-hidden=\"true\" style={{ height: virtualTopOffset }} />;\n};\n\nexport default memo( Scroller );","import React from \"react\";\nimport Scroller from \"../../common/Scroller\";\n\n/*\n    According to specs, tr must always be inside tbody, thead or tfoot                \n*/\nconst TbodyScroller = () => (\n    <tbody className=\"afvscr-scroller\" aria-hidden=\"true\">\n        <Scroller Component=\"tr\" />\n    </tbody>\n);\n\nexport default TbodyScroller;","import React, { cloneElement, memo } from \"react\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#widgetScrollHeight\" ];\n\nconst el = <div aria-hidden=\"true\" className=\"afvscr-height-provider\" />;\n\nconst HeightProvider = () => {\n\n    const { widgetScrollHeight: height } = useApi( SUBSCRIBE_EVENTS );\n\n    const props = {\n        style: {\n            height\n        }\n    };\n\n    return cloneElement( el, props );\n};\n\nexport default memo( HeightProvider );","import React, { forwardRef, useCallback, useEffect } from \"react\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [];\n\nconst ScrollContainer = forwardRef(({\n    className,\n    children,\n    onScroll,\n    reportScrollLeft,\n    ...props\n}, ref ) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.set( \"scrollTop\", scrollTop );\n        if( reportScrollLeft ){\n            API.set( \"scrollLeft\", scrollLeft );\n        }\n        if( onScroll ){\n            onScroll( e );\n        }\n    }, [ onScroll, reportScrollLeft ]);\n\n    useEffect(() => {\n        const el = ref.current;\n\n        const R = new ResizeObserver( entries => {\n            if( entries.length === 1 ){\n                const { width, height } = entries[ 0 ].contentRect;\n\n                API\n                    .set( \"widgetHeight\", Math.round( height ) )\n                    .set( \"widgetWidth\", Math.round( width ) );\n            }\n        });\n\n        R.observe( el );\n\n        return () => {\n            R.unobserve( el );\n        };\n    }, []);\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n    */\n    return (\n        <div tabIndex=\"0\" className={cx(\"afvscr-scroll-container\",className)} ref={ref} onScroll={scrollHandler} {...props}>\n            <HeightProvider />\n            {children}\n        </div>\n    );\n});\n\nexport default ScrollContainer;","import React, { memo, useMemo } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport useApi from \"../../useApi\";\nimport TableWrapper from \"./TableWrapper\";\n\nimport Thead from \"../common/Thead\";\nimport Tfoot from \"../common/Tfoot\";\nimport Tbody from \"../common/Tbody\";\nimport BodyTable from \"../common/BodyTable\";\n\nimport useColWidthsResizeObserver from \"./useColWidthsResizeObserver\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport cx from \"../../utils/cx\";\n\nconst subscribeEvents = [\n    \"#headlessMode\",\n    \"#totals\"\n];\n\nconst NonSticky = ({\n    className,\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    fixedLayout,\n    onScroll,\n    ...props\n}) => {\n\n    const API = useApi( subscribeEvents );\n\n    const { headlessMode, totals } = API;\n\n    /*\n        Hidden tfoot & thead are needed to 'hold' widths of tbody columns no to be narrower than real thead/tfoot\n        and notify model about columns width changes.\n        There are 3 tables rendered in this mode, so their column widths need to be synced somehow.\n    */\n    const widthsObserverRef = useColWidthsResizeObserver( API );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( headlessMode && !totals ){\n            console.warn( \"NonSticky table is rendered without headers and footers. This is not ok.\" )\n        }\n    }\n\n    return (\n        <div className={cx(\"afvscr-nonst\",className)} {...props}>\n            {headlessMode ? null : (\n                <TableWrapper className=\"afvscr-nonst-subtable\">\n                    <Thead />\n                </TableWrapper>\n            )}\n            <ScrollContainer ref={scrollContainerRef} onScroll={onScroll} reportScrollLeft>\n                {useMemo(() => (\n                    <BodyTable fixedLayout={fixedLayout}>\n                        <Colgroup />\n                        {headlessMode ? null : (\n                            <Thead\n                                className=\"afvscr-hdnwrp\"\n                                trRef={widthsObserverRef}\n                            />\n                        )}\n                        {totals && (\n                            <Tfoot\n                                TotalsCellComponent={TotalsCellComponent}\n                                className=\"afvscr-hdnwrp\"\n                                trRef={headlessMode?widthsObserverRef:undefined}\n                            />\n                        )}\n                        <TbodyScroller />\n                        <Tbody\n                            tbodyRef={tbodyRef}\n                            getRowExtraProps={getRowExtraProps}\n                            getCellExtraProps={getCellExtraProps}\n                            RowComponent={RowComponent}\n                            CellComponent={CellComponent}\n                        />\n                    </BodyTable>\n                ), [ totals, headlessMode, fixedLayout, getRowExtraProps, getCellExtraProps, RowComponent, CellComponent, TotalsCellComponent ])}\n            </ScrollContainer>\n            {totals && (\n                <TableWrapper className=\"afvscr-nonst-subtable\">\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                </TableWrapper>\n            )}\n        </div>\n    );\n};\n\nexport default memo( NonSticky );","import React, { memo, useMemo, useEffect } from \"react\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport Thead from \"../common/Thead\";\nimport Tbody from \"../common/Tbody\";\nimport Tfoot from \"../common/Tfoot\";\nimport BodyTable from \"../common/BodyTable\";\nimport useApi from \"../../useApi\";\nimport cx from \"../../utils/cx\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#headlessMode\",\n    \"#totals\"\n];\n\n\n/*\n    Todo:\n        measure thead & tfoot heights in order to properly calculate available space for rows\n*/\n\n\nconst Sticky = ({\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    fixedLayout,\n    className,\n    ...props\n}) => {\n\n    const { headlessMode, totals } = useApi( SUBSCRIBE_EVENTS );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        /*\n            https://bugs.chromium.org/p/chromium/issues/detail?id=702927\n        */\n\n        const areTotalsPresent = totals && totals.length !== 0;\n\n        useEffect(() => {\n            if( !headlessMode || areTotalsPresent ){\n\n                const table = scrollContainerRef.current.querySelector( \"table\" );\n                const tableStyle = getComputedStyle( table );\n\n                if( tableStyle.borderCollapse === \"collapse\" ){\n                    console.warn(\n                        \"You use sticky table version. Due to special border behavior when scrolling, use border-collpase: separate.%o\",\n                        \"https://bugs.chromium.org/p/chromium/issues/detail?id=702927\"\n                    );\n                }\n            }\n        }, [ headlessMode, areTotalsPresent ]);\n    }\n    \n    return (\n        <ScrollContainer ref={scrollContainerRef} reportScrollLeft className={cx(\"afvscr-st\",className)} {...props}>\n            {useMemo(() => (\n                <BodyTable fixedLayout={fixedLayout}>\n                    <Colgroup />\n                    {headlessMode?null:<Thead />}\n                    <TbodyScroller />\n                    <Tbody\n                        tbodyRef={tbodyRef}\n                        getRowExtraProps={getRowExtraProps}\n                        getCellExtraProps={getCellExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                    />\n                    {totals && (\n                        <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                    )}\n                </BodyTable>\n            ), [ headlessMode, fixedLayout, totals, getRowExtraProps, getCellExtraProps, RowComponent, CellComponent, TotalsCellComponent ])}\n        </ScrollContainer>\n    );\n}\n\nexport default memo( Sticky );","const commonDefaultProps = {\n    fixedSize: false,\n    rowCount: 0,\n    overscanRowsCount: 4\n};\n\nexport default commonDefaultProps;","import React, { memo, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport isPositionStickySupported from \"../utils/isPositionStickySupported\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\n\nimport FixedSizeTableStore from \"../models/FixedSizeTable\";\nimport VariableSizeTableStore from \"../models/VariableSizeTable\";\n\nimport RowComponentDefault from \"./common/Row\";\nimport CellComponentDefault from \"./common/Cell\";\nimport TotalsCellComponentDefault from \"./common/TotalsCell\";\n\nimport RowCountWarningContainerDefault from \"../common/RowCountWarningContainer\";\n\nimport NonStickyComponent from \"./NonSticky\";\nimport StickyComponent from \"./Sticky\";\n\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nconst Table = ({\n    fixedSize,\n    columns,\n    totals,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    rowCount,\n    overscanRowsCount,\n    rowCountWarningsTable,\n    headless,\n    RowCountWarningContainer,\n    dataRef,\n    useStickyIfPossible,\n    className,\n    ...props\n}) => {\n\n    const scrollContainerRef = useRef();\n    const tbodyRef = useRef();\n\n    const Store = useStore( fixedSize ? FixedSizeTableStore : VariableSizeTableStore, dataRef );\n\n    useEffect(() => {\n        Store.merge({\n            headlessMode: headless,\n            rowDataGetter: getRowData,\n            rowKeyGetter: getRowKey,\n            overscanRowsCount,\n            totals,\n            columns,\n            totalRows: Math.max( rowCount, 0 ),\n            rowsContainerNode: tbodyRef.current,\n            scrollContainerNode: scrollContainerRef.current\n        });\n    });\n\n    /*\n        Only cells inside thead/tfoot can be sticky.\n        If thead/tfoot are hidden - we can easily render lighter StickyComponent to avoid extra wrappers\n    */\n    const ComponentVariant = ( headless && !totals ) || ( useStickyIfPossible && isPositionStickySupported() ) ? StickyComponent : NonStickyComponent;\n\n    return (\n        <Context.Provider value={Store}>\n            { rowCount > 0 ? (\n                <ComponentVariant\n                    className={cx(\"afvscr-table-wrapper\",className)}\n                    scrollContainerRef={scrollContainerRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    tbodyRef={tbodyRef}\n                    {...props}\n                />\n            ) : rowCountWarningsTable ? (\n                <RowCountWarningContainer>\n                    {rowCountWarningsTable[rowCount]}\n                </RowCountWarningContainer>\n            ) : null }\n        </Context.Provider>\n    );\n}\n\nTable.propTypes = {\n    ...commonPropTypes,\n    columns: PropTypes.arrayOf(\n        PropTypes.shape({\n            // unique key for column\n            dataKey: PropTypes.string.isRequired,\n\n            // If rowData is available, cellData goes through flow, where each fn is optional: render(format((getCellData(rowData,rowIndex))),rowData)\n            // If not, it goes through flow: getEmptyCellData(rowIndex, column).\n            getCellData: PropTypes.func,\n            getEmptyCellData: PropTypes.func,\n            format: PropTypes.func,\n            formatTotal: PropTypes.func,\n\n            visibility: PropTypes.oneOf([ \"visible\", \"hidden\" ]),\n            sort: PropTypes.oneOf([ \"locale\", \"numeric\" ]),\n\n            // column props, affecting colgroup > col tags\n            background: PropTypes.string,\n            border: PropTypes.string,\n            width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n            CellComponent: PropTypes.any,\n            getCellExtraProps: PropTypes.func\n        })\n    ).isRequired,\n\n    getCellExtraProps: PropTypes.func,\n\n    totals: PropTypes.objectOf(\n        // array may contain: \"sum\", \"average\", \"count\", \"max\", \"min\"\n        PropTypes.array\n    ),\n    \n    useStickyIfPossible: PropTypes.bool,\n    headless: PropTypes.bool,\n\n    HeaderRowComponent: PropTypes.any,\n    CellComponent: PropTypes.any,\n    TotalsCellComponent: PropTypes.any,\n\n    RowCountWarningContainer: PropTypes.any,\n    rowCountWarningsTable: PropTypes.object,\n\n    // Determines, if table-layout: fixed is applied to main table\n    fixedLayout: PropTypes.bool\n};\n\nTable.defaultProps = {\n    ...commonDefaultProps,\n    fixedLayout: false,\n    headless: false,\n\n    //    For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n    //    If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n    //    memo(observer(RowComponentDefault)) will do the trick.\n    \n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    TotalsCellComponent: TotalsCellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default memo( Table );","import React from \"react\";\nimport Table from \"af-virtual-scroll/src/Table\";\nimport r from \"lodash/random\";\nimport times from \"lodash/times\";\nimport faker from \"faker\";\nimport { css } from \"@emotion/core\";\n\nconst tableCss = css`\n    th, tfoot td {\n        background: #fff;\n    }\n`;\n\nconst columns = [\n    {\n        dataKey: \"rowIndex\",\n        label: \"Row index\",\n        getCellData: ( rowData, i ) => i\n    },\n    {\n        dataKey: \"num\",\n        label: \"Numeric\",\n        sort: \"numeric\"\n    },\n    {\n        dataKey: \"str\",\n        label: \"String\",\n        sort: \"locale\"\n    },\n    {\n        dataKey: \"rect\",\n        label: \"Rectangle\",\n        render: cellData => (\n            <div style={{\n                lineHeight: `${cellData}px`,\n                background: `hsl(${r(0,360)},50%,50%)`\n            }}>\n                height: {cellData}px\n            </div>\n        )\n    }\n];\n\nconst rowCount = 100000;\n\nconst rows = times( rowCount, () => ({\n    num: r( 1, 20000 ),\n    str: faker.name.findName(),\n    rect: r( 50, 250 )\n}));\n\nconst getRowData = index => rows[ index ];\n\nconst totals = {\n    num: [ \"sum\", \"count\" ]\n};\n\nconst VariableRowHeightsTable = ({ className }) => (\n    <Table\n        css={tableCss}\n        className={className}\n        useStickyIfPossible\n        totals={totals}\n        getRowData={getRowData}\n        rowCount={rowCount}\n        columns={columns}\n    />\n);\n\nexport default VariableRowHeightsTable;"],"sourceRoot":""}