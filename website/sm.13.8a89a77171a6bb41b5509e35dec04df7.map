{"version":3,"sources":["webpack:///./src/Context.js","webpack:///./src/utils/useStore/index.js","webpack:///./src/models/EventEmitter.js","webpack:///./src/models/ListBase.js","webpack:///./src/models/VariableSizeList.js","webpack:///./src/models/FixedSizeList.js","webpack:///./src/useApi/index.js","webpack:///./src/common/HeightProvider.js","webpack:///./src/common/ScrollContainer.js","webpack:///./src/utils/getRowProps/index.js","webpack:///./src/List/common/Row.js","webpack:///./src/List/common/Rows.js","webpack:///./src/common/Scroller.js","webpack:///./src/common/RowCountWarningContainer.js","webpack:///./src/commonDefaultProps.js","webpack:///./src/List/index.js","webpack:///./websiteSrc/examples/list/withFeatures.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/toInteger.js"],"names":["createContext","useStore","StoreConstructor","dataRef","finalDataRef","useRef","Store","current","useEffect","destructor","EventEmitter","_T","Object","create","_a","eventName","fn","prepend","once","eventsQueue","this","that","originalFn","apply","off","arguments","on","prependListener","prependOnceListener","idx","indexOf","splice","emit","a1","a2","a3","a4","i","evt","argsArr","j","argLen","length","call","Array","removeAllListeners","prototype","removeListener","addListener","getRowDataInitial","Error","ListBase","totalRows","startIndex","endIndex","virtualTopOffset","widgetScrollHeight","overscanRowsCount","estimatedRowHeight","scrollTop","widgetHeight","widgetWidth","rowKeyGetter","undefined","rowDataGetter","rowsContainerNode","scrollContainerNode","increaseEndIndexIfNeeded","debounce","currentVisibleDist","getDistanceBetweenIndexes","updateEndIndex","updateWidgetScrollHeight","cancel","updateStartOffset","set","paramName","paramValue","merge","params","k","reportRowsRendered","getVisibleRangeStart","newVisibleStartIndex","remainder","newStartIndex","Math","max","overscanOffset","newEndIndex","min","scrollToRow","index","node","clamp","scrollToStart","SegmentsTreeCache","Uint32Array","DEFAULT_HEIGHS_CACHE","VariableSizeList","sTree","N","shouldResetInvisibleRowHeights","setVisibleRowsHeights","newHeight","l","r","rowHeightsSum","rowCounter","child","firstElementChild","nextElementSibling","parseInt","getAttribute","offsetHeight","round","calculateParentsInRange","maxWait","resetMeasurementsCache","markResetInvisibleRowHeights","dist","v","nodeIndex","ceil","log2","prevTotalRows","fill","res","FixedSizeList","updateEstimatedRowHeight","distance","reducer","x","useApi","subscribeEvents","API","useContext","Context","up","useReducer","useLayoutEffect","SUBSCRIBE_EVENTS","heightProviderClass","el","aria-hidden","className","memo","props","style","height","cloneElement","scrollContainerClass","ScrollContainer","forwardRef","ref","children","onScroll","reportScrollLeft","scrollHandler","useCallback","e","target","scrollLeft","resizeHandler","width","useResizeObserver","onResize","tabIndex","getRowProps","rowData","rowIndex","getRowExtraProps","extraProps","assign","Row","getRowData","propTypes","Rows","RowComponent","rangeFrom","rangeTo","getRowKey","rowKey","result","push","key","getVisibleRows","Component","useApiPlugin","visibility","wrapperClass","RowCountWarningContainer","commonDefaultProps","fixedSize","rowCount","List","rowCountWarningsTable","RowComponentDefault","scrollContainerRef","rowsContainerRef","FixedSizeListStore","VariableSizeListStore","Provider","value","defaultProps","RowCountWarningContainerDefault","wrapperCss","heights","times","lineHeight","borderTop","background","ListWithScrollToRowButton","css","onSubmit","preventDefault","currentTarget","elements","scrollRow","name","type","defaultValue","toNumber","module","exports","toFinite"],"mappings":";gHAEeA,G,KAAAA,2BCwBAC,EApBE,SAAEC,EAAkBC,GACjC,IAAMC,EAAeC,mBAEjBC,EAAQF,EAAaG,QAczB,OAZKD,GAAYA,aAAiBJ,IAC9BI,EAAQF,EAAaG,QAAU,IAAIL,GAGnCC,IACAA,EAAQI,QAAUD,GAGtBE,qBAAU,kBAAM,WACZF,EAAMG,gBACP,CAAEH,IAEEA,G,+CCvBLI,E,6BAEFC,GAAKC,OAAOC,OAAQ,M,2BAEpBC,GAAA,SAAIC,EAAWC,EAAIC,EAASC,GACxB,IAAIC,EAAcC,KAAKT,GAAII,GAG3B,GAAIG,EAAM,CACN,IAAMG,EAAOD,KACTE,EAAaN,EAMjBA,EAAK,WACDM,EAAWC,MAAOF,EAAKG,IAAKT,EAAWC,GAAMS,YASrD,OALKN,IACDA,EAAcC,KAAKT,GAAII,GAAc,IAGzCI,EAAaF,EAAU,UAAY,QAAUD,GACtCI,M,EAGXM,GAAA,SAAIX,EAAWC,GACX,OAAOI,KAAKN,GAAIC,EAAWC,GAAI,GAAO,I,EAG1CW,gBAAA,SAAiBZ,EAAWC,GACxB,OAAOI,KAAKN,GAAIC,EAAWC,GAAI,GAAM,I,EAGzCY,oBAAA,SAAqBb,EAAWC,GAC5B,OAAOI,KAAKN,GAAIC,EAAWC,GAAI,GAAM,I,EAGzCE,KAAA,SAAMH,EAAWC,GACb,OAAOI,KAAKN,GAAIC,EAAWC,GAAI,GAAO,I,EAG1CQ,IAAA,SAAKT,EAAWC,GACZ,IAAMG,EAAcC,KAAKT,GAAII,GAC7B,GAAII,EAAa,CACb,IAAMU,EAAMV,EAAYW,QAASd,IACpB,IAATa,GACAV,EAAYY,OAAQF,EAAK,GAGjC,OAAOT,M,EAGXY,KAAA,SAAMjB,EAAWkB,EAAIC,EAAIC,EAAIC,GACzB,IAAMjB,EAAcC,KAAKT,GAAII,GAC7B,GAAII,EAAa,CACb,IAAK,IAAWkB,EAAGC,EAAgCC,EAA1CC,EAAI,EAAWC,EAAShB,UAAUiB,OAAiBF,EAAIrB,EAAYuB,OAAQF,IAEhF,OADAF,EAAMnB,EAAaqB,GACXC,GACJ,KAAK,EAAGH,EAAIK,KAAMvB,MAAQ,MAC1B,KAAK,EAAGkB,EAAIK,KAAMvB,KAAMa,GAAM,MAC9B,KAAK,EAAGK,EAAIK,KAAMvB,KAAMa,EAAIC,GAAM,MAClC,KAAK,EAAGI,EAAIK,KAAMvB,KAAMa,EAAIC,EAAIC,GAAM,MACtC,KAAK,EAAGG,EAAIK,KAAMvB,KAAMa,EAAIC,EAAIC,EAAIC,GAAM,MAC1C,QACI,IAAKG,EACD,IAAKF,EAAI,EAAGE,EAAU,IAAIK,MAAOH,EAAS,GAAKJ,EAAII,EAAQJ,IACvDE,EAASF,EAAI,GAAMZ,UAAWY,GAGtCC,EAAIf,MAAOH,KAAMmB,GAI7B,OAAO,EAEX,OAAO,G,EAGXM,mBAAA,SAAoB9B,GAOhB,OANIA,EACAK,KAAKT,GAAII,GAAc,GAGvBK,KAAKT,GAAKC,OAAOC,OAAQ,MAEtBO,M,KAIfV,EAAaoC,UAAUC,eAAiBrC,EAAaoC,UAAUtB,IAC/Dd,EAAaoC,UAAUE,YAActC,EAAaoC,UAAUpB,GAE7ChB,Q,iBC5Ff,IAAMuC,EAAoB,WACtB,MAAM,IAAIC,MAAO,gCAkINC,E,qDAhFX,aAAa,aACT,sBA3CJC,UAAY,EA0CC,EAzCbC,WAAa,EAyCA,EAxCbC,SAAW,EAwCE,EAtCbC,iBAAmB,EAsCN,EArCbC,mBAAqB,EAqCR,EAnCbC,kBAAoB,EAmCP,EAlCbC,mBAZiC,GA8CpB,EAhCbC,UAAY,EAgCC,EA/BbC,aAAe,EA+BF,EA9BbC,YAAc,EA8BD,EA5BbC,kBAAeC,EA4BF,EA3BbC,cAAgBf,EA2BH,EA1BbgB,kBAAoB,KA0BP,EAzBbC,oBAAsB,KAyBT,EA6BbC,yBAA2BC,KAAS,WAChC,IAAMC,EAAqB,EAAKC,0BAA2B,EAAKjB,WAAY,EAAKC,UAIjF,OAHI,EAAKM,aAAe,EAAKL,iBAAmBc,EAAqB,EAAKV,WACtE,EAAKY,iBAET,iBAjFyB,KA8DzB,EACK7C,GAAI,aAAc,EAAK8C,0BACvB9C,GAAI,aAAc,EAAK6C,gBACvB7C,GAAI,sBAAuB,EAAKyC,0BAChCzC,GAAI,YAAa,EAAKyC,yBAAyBM,QAC/C/C,GAAI,aAAc,EAAKgD,mBACvBhD,GAAI,qBAAsB,EAAKgD,mBAC/BhD,GAAI,gBAAiB,EAAK6C,gBAC1B7C,GAAI,cAAe,EAAK6C,gBAvBpB,E,SAvBbI,IAAA,SAAKC,EAAWC,GAaZ,OALIzD,KAAMwD,KAAgBC,IACtBzD,KAAMwD,GAAcC,EACpBzD,KAAKY,KAAL,IAAe4C,IAGZxD,M,EAGX0D,MAAA,SAAOC,GACH,IAAK,IAAIC,KAAKD,EACV3D,KAAKuD,IAAKK,EAAGD,EAAQC,IAEzB,OAAO5D,M,EAwCXX,WAAA,WACIW,KAAK+C,yBAAyBM,SAC9BrD,KAAKyB,sB,EAGToC,mBAAA,WACI7D,KAAKY,KAAM,kB,EAGf0C,kBAAA,WAAmB,IACPf,EAAiCvC,KAAjCuC,UAAWF,EAAsBrC,KAAtBqC,kBADJ,EAE6BrC,KAAK8D,qBAAsBvB,GAA/DwB,EAFO,KAEeC,EAFf,KAGTC,EAAgBC,KAAKC,IAAK,EAAGJ,EAAuB1B,GACpD+B,EAAiBpE,KAAKkD,0BAA2Be,EAAeF,GAEtE,OAAO/D,KACFuD,IAAK,mBAAoBhB,EAAYyB,EAAYI,GACjDb,IAAK,aAAcU,I,EAG5Bd,eAAA,WAAgB,IACJkB,EAAgBrE,KAAK8D,qBAAsB9D,KAAKuC,UAAYvC,KAAKwC,cAD7D,GAMZ,OAAOxC,KAAKuD,IAAK,WAAYW,KAAKI,IAAKD,EAAc,EAAIrE,KAAKqC,kBAAmBrC,KAAKgC,a,EAG1FuC,YAAA,SAAaC,GACT,IAAMC,EAAOzE,KAAK8C,oBAKlB,OAJI2B,IACAD,EAAQE,IAAOF,EAAO,EAAGxE,KAAKgC,WAC9ByC,EAAKlC,UAAYvC,KAAKkD,0BAA2B,EAAGsB,IAEjDxE,M,EAGX2E,cAAA,WACI,OAAO3E,KAAKuE,YAAa,I,GAxHVjF,GCPvB,IAAMsF,EAAoBC,YAepBC,EAAuB,IAAIF,EAAmB,GAsMrCG,E,qDAnCX,aAAa,aACT,sBA/JJC,MAAQF,EA8JK,EA7JbG,EAAI,EA6JS,EArJbC,gCAAiC,EAqJpB,EA3HbC,sBAAwBnC,KAAS,WAC7B,IAAMyB,EAAO,EAAK5B,kBAElB,GAAI4B,EAAM,CAYN,IAZM,IAYmCW,EAAWZ,EAZ9C,iBACEQ,EADF,EACEA,MAAOC,EADT,EACSA,EAEXI,GAAK,EACLC,GAAK,EACLC,EAAgB,EAChBC,EAAa,EAMRC,EAAQhB,EAAKiB,kBAAqCD,EAAOA,EAAQA,EAAME,mBAAoBH,IAOhGhB,EAAQoB,SAAUH,EAAMI,aAAc,iBAAmB,IAAO,EAOhEN,GADAH,EAAYK,EAAMK,aAGdd,EAAOC,EAAIT,KAAYY,IAEvBJ,EAAOC,EAAIT,GAAUY,GAEV,IAAPC,IACAA,EAAIb,GAGRc,EAAId,IAID,IAAPa,IAKI,EAAKH,gCACL,EAAK3B,IAAK,qBAAsBW,KAAK6B,MAAOR,EAAgBC,IAC5D,EAAKN,gCAAiC,GAGtC,EACKc,wBAAyBX,EAAGC,GAC5BlC,4BAKjB,wBA1GkC,GA2GA,CAAE6C,QA1GH,MA2KjC,EACK1F,gBAAiB,aAAc,EAAK2F,wBACpC5F,GAAI,sBAAuB,EAAK4F,wBAChC5F,GAAI,sBAAuB,EAAK8C,0BAChC9C,GAAI,gBAAiB,EAAK6E,uBAC1B7E,GAAI,eAAgB,EAAK6F,8BACzB7F,GAAI,eAAgB,EAAK6E,uBATrB,E,SAnJbgB,6BAAA,WACInG,KAAKkF,gCAAiC,G,EAG1C9B,yBAAA,WAEI,OAAOpD,KAAKuD,IAAK,qBAAsBvD,KAAKgF,MAAO,K,EAGvDgB,wBAAA,SAAyB/D,EAAYC,GAAU,IACnC8C,EAAahF,KAAbgF,MAAOC,EAAMjF,KAANiF,EAEf,IAAK/C,GAAY+C,EAAGhD,GAAcgD,EAAG/C,IAAa,GAC9C,IAAK,IAAIjB,EAAIgB,IAAe,EAAGhB,GAAKiB,EAAUjB,IAC1C+D,EAAO/D,GAAM+D,EAAO/D,GAAK,GAAM+D,EAAO/D,GAAK,EAAI,GAIvD,OAAOjB,M,EAqEX8D,qBAAA,SAAsBsC,GAIlB,IAJwB,IAELC,EADXrB,EAAahF,KAAbgF,MAAOC,EAAMjF,KAANiF,EACXqB,EAAY,EAETA,EAAYrB,GAEXmB,IADJC,EAAIrB,EAAOsB,IAAc,MAErBF,GAAQC,EACRC,GAAa,GAIrB,MAAO,CAAEA,EAAYrB,EAAGmB,I,EAG5BF,uBAAA,WAAwB,IACZlE,EAAchC,KAAdgC,UAER,GAAIA,EAAW,KAEHM,EAAuBtC,KAAvBsC,mBACF0C,EAAahF,KAAbgF,MAAOC,EAAMjF,KAANiF,EAEb,GAAIjD,EAAYiD,EACZA,EAAIjF,KAAKiF,EAAL,SAAS,EAAKf,KAAKqC,KAAMrC,KAAKsC,KAAMxE,EAvI5B,MAwIZgD,EAAQhF,KAAKgF,MAAQ,IAAIJ,EAAuB,EAAJK,OAE5C,KACQwB,EAAkBzB,EAD1B,GAOIhD,IAAcyE,GACdzB,EAAM0B,KAAM,EAAG,EAAGzB,EAAIf,KAAKC,IAAKnC,EAAWyE,IAAmB,GAItEzB,EAAM0B,KAAMpE,EAAoB2C,EAAGA,EAAIjD,GAYvChC,KAAKgG,wBAAyB,EAAGhE,QAGjChC,KAAKgF,MAAQF,EAGjB,OAAO9E,M,EAeXX,WAAA,WACIW,KAAKmF,sBAAsB9B,SAC3B,YAAMhE,WAAN,Y,EAGJ6D,0BAAA,SAA2BjB,EAAYC,GAAU,IACrC8C,EAAahF,KAAbgF,MAAOC,EAAMjF,KAANiF,EACX0B,EAAM,EAEV,IAAK1E,GAAcgD,EAAG/C,GAAY+C,EAAGhD,EAAaC,EAAUD,IAAe,EAAGC,IAAa,EACtE,EAAbD,IACA0E,GAAO3B,EAAO/C,MAGH,EAAXC,IACAyE,GAAO3B,IAAS9C,IAIxB,OAAOyE,G,GAhMgB5E,G,ICgBhB6E,E,qDAbX,aAAa,aACT,sBAGKtG,GAAI,sBAAuB,EAAK8C,0BAChC9C,GAAI,eAAgB,EAAKuG,0BALrB,E,SApBbzD,yBAAA,WACI,OAAOpD,KAAKuD,IAAK,qBAAsBvD,KAAKsC,mBAAqBtC,KAAKgC,Y,EAG1E6E,yBAAA,WACI,IAAMpC,EAAOzE,KAAK6C,kBAEd4B,IAC8BA,EAAtBiB,mBAEJ1F,KAAKuD,IAAK,qBAAsBkB,EAAKiB,kBAAkBI,gB,EAKnEhC,qBAAA,SAAsBgD,GAAU,IACpBxE,EAAuBtC,KAAvBsC,mBACR,MAAO,CAAEwE,EAAWxE,EAAqB,EAAGwE,EAAWxE,I,EAW3DY,0BAAA,SAA2BjB,EAAYC,GACnC,OAAOlC,KAAKsC,oBAAuBJ,EAAWD,I,GA/B1BF,G,QCCtBgF,EAAU,SAAAC,GAAC,OAAIA,EAAI,GA2BVC,EApBA,SAAAC,GAEd,IAAMC,EAAMC,qBAAYC,GAEfC,EAAMC,qBAAYR,EAAS,GAJH,GAiBjC,OAXAS,2BAAgB,WACf,IAAK,IAAIpG,EAAI,EAAGA,EAAI8F,EAAgB5F,OAAQF,IAC3C+F,EAAI7G,GAAI4G,EAAiB9F,GAAKkG,GAE/B,OAAO,WACN,IAAK,IAAIlG,EAAI,EAAGA,EAAI8F,EAAgB5F,OAAQF,IAC3C+F,EAAI/G,IAAK8G,EAAiB9F,GAAKkG,MAG/BJ,GAEIC,G,OCvBR,IAAMM,EAAmB,CAAE,uBAErBC,EAAmB,kJAQnBC,EAAK,mBAAKC,cAAY,OAAOC,UAAWH,IAe/BI,kBAbQ,WAAM,IAInBC,EAAQ,CACVC,MAAO,CACHC,OAJ+BhB,EAAQQ,GAAvCrF,qBAQR,OAAO8F,uBAAcP,EAAII,MCpB7B,IAAMN,EAAmB,GAMnBU,EAAoB,iKA+CXC,EAvCSC,sBAAW,WAMhCC,GAAS,IALRT,EAKQ,EALRA,UACAU,EAIQ,EAJRA,SACAC,EAGQ,EAHRA,SACAC,EAEQ,EAFRA,iBACGV,EACK,sEAEFZ,EAAMF,EAAQQ,GAEdiB,EAAgBC,uBAAa,SAAAC,GAAK,MACFA,EAAEC,OAA5BtG,EAD4B,EAC5BA,UAAWuG,EADiB,EACjBA,WACnB3B,EAAI5D,IAAK,YAAahB,GAClBkG,GACAtB,EAAI5D,IAAK,aAAcuF,GAEvBN,GACAA,EAAUI,KAEf,CAAEJ,EAAUC,IAETM,EAAgBJ,uBAAY,YAAuB,IAApBK,EAAoB,EAApBA,MAAOf,EAAa,EAAbA,OACxCd,EAAI5D,IAAK,eAAgB0E,GAAS1E,IAAK,cAAeyF,KACvD,IAQH,OANAC,YAAkB,CAAEX,MAAKY,SAAUH,IAO/B,+BAAKI,SAAS,IAAItB,UAAW,YAAGM,EAAqBN,GAAYS,IAAKA,EAAKE,SAAUE,GAAmBX,GACpG,YAAC,EAAD,MACCQ,MChCEa,EAtBK,SAAEC,EAASC,EAAUC,GAGrC,IAAMxB,EAAQ,CACV,gBAAiBuB,EAAW,GAGhC,GAAIC,EAAkB,CAClB,IAAMC,EAAaD,EAAkBF,EAASC,GAC1CE,GAMAhK,OAAOiK,OAAQ1B,EAAOyB,GAI9B,OAAOzB,GCfL2B,EAAM,SAAC,GAA+C,IAA7CC,EAA6C,EAA7CA,WAAYJ,EAAiC,EAAjCA,iBAAkBD,EAAe,EAAfA,SAEnCD,EAAUM,EAAYL,GAE5B,OACI,kBAASF,EAAYC,EAASC,EAAUC,GACnCF,IAKbK,EAAIE,UAAJ,GAMeF,QClBTjC,EAAmB,CACrB,cACA,YACA,gBACA,kBA4CWoC,EAlBF,SAAC,GAAuC,IAArCN,EAAqC,EAArCA,iBAAkBO,EAAmB,EAAnBA,aAExB3C,EAAMF,EAAQQ,GAMpB,OAJArI,qBAAU,WACN+H,EAAItD,wBA5BW,SACnBkG,EACAC,EACAL,EACAM,EACAV,EACAO,GAGA,IADA,IACSI,EADHC,EAAS,GACEJ,EAAYC,EAASD,IAClCG,EAASD,EAAYA,EAAWF,GAAcA,EAC9CI,EAAOC,KACH,YAACN,EAAD,CACIP,iBAAkBA,EAClBD,SAAUS,EACVM,IAAKH,EACLP,WAAYA,KAIxB,OAAOQ,EAWAG,CACHnD,EAAIlF,WACJkF,EAAIjF,SACJiF,EAAIvE,cACJuE,EAAIzE,aACJ6G,EACAO,IC5CFrC,EAAmB,CAAE,qBAWZK,kBATE,SAAC,GAAkB,IAAhByC,EAAgB,EAAhBA,UAERpI,EAAqBqI,EAAc/C,GAAnCtF,iBAIR,OAAO,YAACoI,EAAD,CAAW3C,cAAY,OAAOI,MAAO,CAAEC,OAAQ9F,EAAkBsI,WAAY,eCRxF,IAAMC,EAAY,6JAUHC,EAFkB,SAAC,GAAD,IAAG9C,EAAH,EAAGA,UAAcE,EAAjB,oCAA6B,+BAAKF,UAAW,YAAG6C,EAAa7C,IAAgBE,KCL/F6C,EANY,CACvBC,WAAW,EACXC,SAAU,EACVzI,kBAAmB,GCoBvB,IAAMqI,EAAY,4HASZK,EAAO,SAAC,GAYR,IAXFF,EAWE,EAXFA,UACAlB,EAUE,EAVFA,WACAM,EASE,EATFA,UACAV,EAQE,EARFA,iBACAuB,EAOE,EAPFA,SACAzI,EAME,EANFA,kBACA2I,EAKE,EALFA,sBACAL,EAIE,EAJFA,yBAIE,IAHFb,oBAGE,MAHamB,EAGb,EAFFlM,EAEE,EAFFA,QACGgJ,EACD,oLAEImD,EAAqBjM,mBACrBkM,EAAmBlM,mBAEnBC,EAAQL,EAAUgM,EAAYO,EAAqBC,EAAuBtM,GAahF,OAXAK,qBAAU,WACNF,EAAMwE,MAAM,CACRd,cAAe+G,EACfjH,aAAcuH,EACd5H,oBACAL,UAAW8I,EACXjI,kBAAmBsI,EAAiBhM,QACpC2D,oBAAqBoI,EAAmB/L,aAK5C,YAACkI,EAAQiE,SAAT,CAAkBC,MAAOrM,GACnB4L,EAAW,EACT,YAAC,EAAD,aACIjD,UAAW6C,EACXpC,IAAK4C,GACDnD,GAEJ,YAAC,EAAD,CAAUwC,UAAU,QACpB,mBAAKjC,IAAK6C,GACN,YAAC,EAAD,CAAMrB,aAAcA,EAAcP,iBAAkBA,MAG5DyB,EACA,YAACL,EAAD,KACKK,EAAsBF,IAE3B,OAKhBC,EAAKnB,UAAL,GAMAmB,EAAKS,aAAL,iBACOZ,EADP,CAUId,aAAchC,eAAMmD,GACpBN,yBAA0Bc,IAGf3D,qBAAMiD,G,yBClGrB,IAAMW,EAAa,CAAH,2FAOVC,E,MAAUC,GAFC,KAEgB,kBAAMtG,IAAG,GAAI,QAExCqE,EAAa,SAAAnF,GAAK,OACpB,mBAAKwD,MAAO,CACR6D,WAAeF,EAAQnH,GAAb,KACVsH,UAAW,iBACXC,WAAY,OAAOzG,IAAE,EAAE,KAAb,IAAqBA,IAAE,GAAG,IAA1B,KAAkCA,IAAE,GAAG,IAAvC,OAHd,MAKQd,EALR,KAKsBmH,EAAQnH,GAL9B,OA2CWwH,UAlCmB,SAAC,GAAkB,IAAhBnE,EAAgB,EAAhBA,UAE3B9I,EAAUE,mBAQhB,OACI,mBAAKgN,IAAKP,EAAY7D,UAAWA,GAC7B,oBAAMqE,SARQ,SAAAtD,GAClBA,EAAEuD,iBACF,IAAM9F,EAAIuC,EAAEwD,cAAcC,SAASC,UAAUf,MAC7CxM,EAAQI,QAAQoF,aAAc8B,KAMtB,iCAEI,qBACIkG,KAAK,YACLC,KAAK,SACLC,aAAa,OAGrB,sBAAQD,KAAK,UAAb,WAIJ,YAAC,EAAD,CACIzN,QAASA,EACT4K,WAAYA,EACZmB,SA1CC,S,mBCXjB,IAAI4B,EAAW,EAAQ,IAyCvBC,EAAOC,QAZP,SAAkBrB,GAChB,OAAKA,GAGLA,EAAQmB,EAASnB,MA9BJ,KA+BaA,KA/Bb,IACG,uBA+BFA,EAAQ,GAAK,EAAI,GAGxBA,GAAUA,EAAQA,EAAQ,EAPd,IAAVA,EAAcA,EAAQ,I,iBCXjCoB,EAAOC,QAJP,SAAkBrB,GAChB,OAAOA,I,mBCjBT,IAAIsB,EAAW,EAAQ,IAmCvBF,EAAOC,QAPP,SAAmBrB,GACjB,IAAIpB,EAAS0C,EAAStB,GAClBvH,EAAYmG,EAAS,EAEzB,OAAOA,GAAWA,EAAUnG,EAAYmG,EAASnG,EAAYmG,EAAU","file":"13.b07dd2893caa733c0d13.js","sourcesContent":["import { createContext } from \"react\";\n\nexport default createContext();","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef ) => {\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !Store || !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    useEffect(() => () => {\n        Store.destructor();\n    }, [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","class EventEmitter {\n\n    _T = Object.create( null );\n\n    _a( eventName, fn, prepend, once ){\n        let eventsQueue = this._T[ eventName ];\n\n        \n        if( once ){\n            const that = this,\n                originalFn = fn;\n\n            /*\n                when using ...args and arrow func, babel is making unnecessary arguments copy.\n                Going old-school here for perf\n            */\n            fn = function(){\n                originalFn.apply( that.off( eventName, fn ), arguments );\n            }\n        }\n    \n        if( !eventsQueue ){\n            eventsQueue = this._T[ eventName ] = [];\n        }\n    \n        eventsQueue[ prepend ? \"unshift\" : \"push\" ]( fn );\n        return this;\n    }\n\n    on( eventName, fn ){\n        return this._a( eventName, fn, false, false );\n    }\n\n    prependListener( eventName, fn ){\n        return this._a( eventName, fn, true, false );\n    }\n\n    prependOnceListener( eventName, fn ){\n        return this._a( eventName, fn, true, true );\n    }\n\n    once( eventName, fn ){\n        return this._a( eventName, fn, false, true );\n    }\n\n    off( eventName, fn ){\n        const eventsQueue = this._T[ eventName ];\n        if( eventsQueue ){\n            const idx = eventsQueue.indexOf( fn );\n            if( idx !== -1 ){\n                eventsQueue.splice( idx, 1 );\n            }\n        }\n        return this;\n    }\n\n    emit( eventName, a1, a2, a3, a4 ){\n        const eventsQueue = this._T[ eventName ];\n        if( eventsQueue ){\n            for( let j = 0, i, evt, argLen = arguments.length, argsArr; j < eventsQueue.length; j++ ){\n                evt = eventsQueue[ j ];\n                switch( argLen ){\n                    case 1: evt.call( this ); break;\n                    case 2: evt.call( this, a1 ); break;\n                    case 3: evt.call( this, a1, a2 ); break;\n                    case 4: evt.call( this, a1, a2, a3 ); break;\n                    case 5: evt.call( this, a1, a2, a3, a4 ); break;\n                    default:\n                        if( !argsArr ){\n                            for( i = 1, argsArr = new Array( argLen - 1 ); i < argLen; i++ ){\n                                argsArr[ i - 1 ] = arguments[ i ];\n                            }\n                        }\n                        evt.apply( this, argsArr );\n                        break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    removeAllListeners( eventName ){\n        if( eventName ){\n            this._T[ eventName ] = [];\n        }\n        else{\n            this._T = Object.create( null );\n        }\n        return this;\n    }\n}\n\nEventEmitter.prototype.removeListener = EventEmitter.prototype.off;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\nexport default EventEmitter;","import clamp from \"lodash/clamp\";\nimport EventEmitter from \"./EventEmitter\";\nimport debounce from \"lodash/debounce\";\n\nconst getRowDataInitial = () => {\n    throw new Error( \"getRowData must be provided\" );\n};\n\nconst END_INDEX_CHECK_INTERVAL = 400;\nconst DEFAULT_ESTIMATED_ROW_HEIGHT = 16;\n\nclass ListBase extends EventEmitter {\n\n    totalRows = 0;\n    startIndex = 0;\n    endIndex = 0;\n\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n\n    overscanRowsCount = 0;\n    estimatedRowHeight = DEFAULT_ESTIMATED_ROW_HEIGHT;\n\n    scrollTop = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n\n    rowKeyGetter = undefined;\n    rowDataGetter = getRowDataInitial;\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    set( paramName, paramValue ){\n\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.hasOwnProperty( paramName ) ){\n                throw new Error( `Trying to merge key, which does not exist: ${paramName}` );\n            }\n        }\n\n        if( this[ paramName ] !== paramValue ){\n            this[ paramName ] = paramValue;\n            this.emit( `#${paramName}` );\n        }\n\n        return this;\n    }\n    \n    merge( params ){\n        for( let k in params ){\n            this.set( k, params[ k ] );\n        }\n        return this;\n    }\n    \n    constructor(){\n        super();\n        \n        if( process.env.NODE_ENV !== \"production\" ){\n            const absentMethods = [\n                \"updateWidgetScrollHeight\",\n                \"getDistanceBetweenIndexes\",\n                \"getVisibleRangeStart\"\n            ].filter( fn => !this[ fn ] );\n\n            if( absentMethods.length ){\n                throw new Error( `Absent methods: ${absentMethods.join( \",\" )}` );\n            }\n        }\n\n        this\n            .on( \"#totalRows\", this.updateWidgetScrollHeight )\n            .on( \"#totalRows\", this.updateEndIndex )\n            .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\n            .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel )\n            .on( \"#scrollTop\", this.updateStartOffset )\n            .on( \"#overscanRowsCount\", this.updateStartOffset )\n            .on( \"#widgetHeight\", this.updateEndIndex )\n            .on( \"#startIndex\", this.updateEndIndex );\n    }\n\n    /*\n        Column heights may change during scroll/width-change\n    */\n    increaseEndIndexIfNeeded = debounce(() => {\n        const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n        return this;\n    }, END_INDEX_CHECK_INTERVAL );\n\n    destructor(){\n        this.increaseEndIndexIfNeeded.cancel();\n        this.removeAllListeners();\n    }\n    \n    reportRowsRendered(){\n        this.emit( \"rows-rendered\" );\n    }\n\n    updateStartOffset(){\n        const { scrollTop, overscanRowsCount } = this;\n        const [ newVisibleStartIndex, remainder ] = this.getVisibleRangeStart( scrollTop );\n        const newStartIndex = Math.max( 0, newVisibleStartIndex - overscanRowsCount );\n        const overscanOffset = this.getDistanceBetweenIndexes( newStartIndex, newVisibleStartIndex );\n                \n        return this\n            .set( \"virtualTopOffset\", scrollTop - remainder - overscanOffset )\n            .set( \"startIndex\", newStartIndex );\n    }\n\n    updateEndIndex(){\n        const [ newEndIndex ] = this.getVisibleRangeStart( this.scrollTop + this.widgetHeight );\n        /*\n            getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return this.set( \"endIndex\", Math.min( newEndIndex + 1 + this.overscanRowsCount, this.totalRows ) );\n    }\n\n    scrollToRow( index ){\n        const node = this.scrollContainerNode;\n        if( node ){\n            index = clamp( index, 0, this.totalRows );\n            node.scrollTop = this.getDistanceBetweenIndexes( 0, index );\n        }\n        return this;    \n    }\n\n    scrollToStart(){\n        return this.scrollToRow( 0 );\n    }\n};\n\nexport default ListBase;","import ListBase from \"./ListBase\";\nimport debounce from \"lodash/debounce\";\n\n// Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\nconst SegmentsTreeCache = Uint32Array;\n\n/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_SIZE = 32;\n\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 50;\nconst ROW_MEASUREMENT_DEBOUNCE_MAXWAIT = 150;\n\n/*\n    Could just make [ 0, 0 ], but want to keep type of heightsCache always of same type.\n*/\nconst DEFAULT_HEIGHS_CACHE = new SegmentsTreeCache( 2 );\n\nclass VariableSizeList extends ListBase {\n\n    /* Two vars for non-recursive segments tree */\n    sTree = DEFAULT_HEIGHS_CACHE;\n    N = 0;\n\n    /*\n        When all row heights are different,\n        we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n        basing on what we know: heights between startIndex and endIndex.\n        Using simple average by default.\n    */\n    shouldResetInvisibleRowHeights = true;\n\n    markResetInvisibleRowHeights(){\n        this.shouldResetInvisibleRowHeights = true;\n    }\n\n    updateWidgetScrollHeight(){\n        /* In segments tree 1 node is always sum of all elements */\n        return this.set( \"widgetScrollHeight\", this.sTree[ 1 ] );\n    }\n\n    calculateParentsInRange( startIndex, endIndex ){\n        const { sTree, N } = this;\n    \n        for( endIndex += N, startIndex += N; endIndex >>= 1; ){\n            for( let i = startIndex >>= 1; i <= endIndex; i++ ){\n                sTree[ i ] = sTree[ i << 1 ] + sTree[ i << 1 | 1 ];\n            }\n        }\n\n        return this;\n    }\n\n    /*\n        TODO: maybe some react-like performUnitOfWork logic is needed here?\n    */\n    setVisibleRowsHeights = debounce(() => {\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { sTree, N } = this;\n            \n            let l = -1,\n                r = -1,\n                rowHeightsSum = 0,\n                rowCounter = 0;\n\n            /*\n                Some benchmarks inspire me to use nextElementSibling\n                https://jsperf.com/nextsibling-vs-childnodes-increment/2\n            */\n            for( let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++ ){\n                \n                /*\n                    * aria-rowindex is counted from 1 according to w3c spec;\n                    * parseInt with radix is 2x faster, then +, -, etc.\n                      https://jsperf.com/number-vs-parseint-vs-plus/116\n                */\n                index = parseInt( child.getAttribute( \"aria-rowindex\" ), 10 ) - 1;\n\n                if( process.env.NODE_ENV !== \"production\" && Number.isNaN( index ) ){\n                    throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                }\n\n                newHeight = child.offsetHeight;\n                rowHeightsSum += newHeight;\n\n                if( sTree[ N + index ] !== newHeight ){\n                    // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n                    sTree[ N + index ] = newHeight;\n                    \n                    if( l === -1 ){\n                        l = index;\n                    }\n                    \n                    r = index;\n                }\n            }\n \n            if( l !== -1 ){\n                if( process.env.NODE_ENV !== \"production\" ){\n                    console.log( \"Updating heights in range: %d - %d\", l, r );\n                }\n\n                if( this.shouldResetInvisibleRowHeights ){\n                    this.set( \"estimatedRowHeight\", Math.round( rowHeightsSum / rowCounter ) );\n                    this.shouldResetInvisibleRowHeights = false;\n                }\n                else{\n                    this\n                        .calculateParentsInRange( l, r )\n                        .updateWidgetScrollHeight();\n                }\n            }\n        }\n\n        return this;\n    }, ROW_MEASUREMENT_DEBOUNCE_INTERVAL, { maxWait: ROW_MEASUREMENT_DEBOUNCE_MAXWAIT });\n    \n    getVisibleRangeStart( dist ){\n        const { sTree, N } = this;\n        let nodeIndex = 1, v;\n\n        while( nodeIndex < N ){\n            v = sTree[ nodeIndex <<= 1 ];\n            if( dist >= v ){\n                dist -= v;\n                nodeIndex |= 1;\n            }\n        }\n\n        return [ nodeIndex - N, dist ];\n    }\n\n    resetMeasurementsCache(){\n        const { totalRows } = this;\n\n        if( totalRows ){\n\n            const { estimatedRowHeight } = this;\n            let { sTree, N } = this;\n\n            if( totalRows > N ){\n                N = this.N = 2 ** Math.ceil( Math.log2( totalRows + MIN_TREE_CACHE_SIZE ) );\n                sTree = this.sTree = new SegmentsTreeCache( N * 2 );\n            }\n            else{\n                const [ prevTotalRows ] = sTree;\n    \n                /*\n                    clearing only what is needed;\n                    TODO: optimize this more\n                */\n                if( totalRows !== prevTotalRows ){\n                    sTree.fill( 0, 2, N + Math.max( totalRows, prevTotalRows ) >> 1 )\n                }\n            }\n\n            sTree.fill( estimatedRowHeight, N, N + totalRows );\n\n            /*\n                Trees are not always ideally allocated, gaps are possible.\n                Classical way for calculating parents is much simpler,\n                but can do much more work(summing zeros) in such conditions. Commented classic algo:\n        \n                for( let i = N + totalRows >> 1, j; i > 0; --i ){\n                    j = i << 1;\n                    sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n                }\n            */\n            this.calculateParentsInRange( 0, totalRows );\n        }\n        else{\n            this.sTree = DEFAULT_HEIGHS_CACHE;\n        }\n\n        return this;\n    }\n\n    constructor(){\n        super();\n\n        this\n            .prependListener( \"#totalRows\", this.resetMeasurementsCache )\n            .on( \"#estimatedRowHeight\", this.resetMeasurementsCache )\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"rows-rendered\", this.setVisibleRowsHeights )\n            .on( \"#widgetWidth\", this.markResetInvisibleRowHeights )\n            .on( \"#widgetWidth\", this.setVisibleRowsHeights );\n    }\n\n    destructor(){\n        this.setVisibleRowsHeights.cancel();\n        super.destructor();\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        const { sTree, N } = this;\n        let res = 0; \n\n        for( startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1 ){\n            if( startIndex & 1 ){\n                res += sTree[ startIndex++ ];\n            }\n\n            if( endIndex & 1 ){\n                res += sTree[ --endIndex ]; \n            }\n        };\n\n        return res; \n    }\n};\n\nexport default VariableSizeList;","import ListBase from \"./ListBase\";\n\nclass FixedSizeList extends ListBase {\n    \n    updateWidgetScrollHeight(){\n        return this.set( \"widgetScrollHeight\", this.estimatedRowHeight * this.totalRows );\n    }\n\n    updateEstimatedRowHeight(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { firstElementChild } = node;\n            if( firstElementChild ){\n                this.set( \"estimatedRowHeight\", node.firstElementChild.offsetHeight );\n            }\n        }\n    }\n\n    getVisibleRangeStart( distance ){\n        const { estimatedRowHeight } = this;\n        return [ distance / estimatedRowHeight | 0, distance % estimatedRowHeight ];\n    }\n\n    constructor(){\n        super();\n\n        this\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"#widgetWidth\", this.updateEstimatedRowHeight );\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        return this.estimatedRowHeight * ( endIndex - startIndex );\n    }\n};\n\nexport default FixedSizeList;","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nconst reducer = x => x + 1;\n\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\nconst useApi = subscribeEvents => {\n\n\tconst API = useContext( Context );\n\n\tconst [, up] = useReducer( reducer, 0 );\n    \n\tuseLayoutEffect(() => {\n\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\tAPI.on( subscribeEvents[ j ], up );\n\t\t}\n\t\treturn () => {\n\t\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\t\tAPI.off( subscribeEvents[ j ], up );\n\t\t\t}\n\t\t};\n\t}, subscribeEvents );\n\n\treturn API;\n};\n\nexport default useApi;\n","import React, { cloneElement, memo } from \"react\";\nimport { css } from \"emotion\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#widgetScrollHeight\" ];\n\nconst heightProviderClass = css`\n    position: absolute;\n    top: 0;\n    left: 0;\n    visibility: hidden;\n    width: 1px;\n`;\n\nconst el = <div aria-hidden=\"true\" className={heightProviderClass} />;\n\nconst HeightProvider = () => {\n\n    const { widgetScrollHeight: height } = useApi( SUBSCRIBE_EVENTS );\n\n    const props = {\n        style: {\n            height\n        }\n    };\n\n    return cloneElement( el, props );\n};\n\nexport default memo( HeightProvider );","import React, { forwardRef, useCallback } from \"react\";\nimport useResizeObserver from \"use-resize-observer\";\nimport { css, cx } from \"emotion\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [];\n\n/*\n    * flex: 1 1 auto, assuming that table would be used full-stretch mostly\n    width: 100% covers case, when no tbody is rendered and exact width cannot be calculated\n*/\nconst scrollContainerClass = css`\n    overflow: auto;\n    outline: none;\n    min-height: 0;\n    flex: 1 1 auto;\n    position: relative;\n`;\n\nconst ScrollContainer = forwardRef(({\n    className,\n    children,\n    onScroll,\n    reportScrollLeft,\n    ...props\n}, ref ) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.set( \"scrollTop\", scrollTop );\n        if( reportScrollLeft ){\n            API.set( \"scrollLeft\", scrollLeft );\n        }\n        if( onScroll ){\n            onScroll( e );\n        }\n    }, [ onScroll, reportScrollLeft ]);\n\n    const resizeHandler = useCallback(({ width, height }) => {\n        API.set( \"widgetHeight\", height ).set( \"widgetWidth\", width );\n    }, []);\n\n    useResizeObserver({ ref, onResize: resizeHandler });\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n    */\n    return (\n        <div tabIndex=\"0\" className={cx(scrollContainerClass,className)} ref={ref} onScroll={scrollHandler} {...props}>\n            <HeightProvider />\n            {children}\n        </div>\n    );\n});\n\nexport default ScrollContainer;","const getRowProps = ( rowData, rowIndex, getRowExtraProps ) => {\n\n    /* avoiding double destructurization via getRowExtraProps, so making prop object once */\n    const props = {\n        \"aria-rowindex\": rowIndex + 1\n    };\n\n    if( getRowExtraProps ){\n        const extraProps = getRowExtraProps( rowData, rowIndex );\n        if( extraProps ){\n            if( process.env.NODE_ENV !== \"production\" ){\n                if( extraProps.hasOwnProperty( \"aria-rowindex\" ) ){\n                    throw new Error( \"getExtraProps must not override aria-rowindex\" );\n                }\n            }\n            Object.assign( props, extraProps );\n        }\n    }\n\n    return props;\n}\n\nexport default getRowProps;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport getRowProps from \"../../utils/getRowProps\";\n\nconst Row = ({ getRowData, getRowExtraProps, rowIndex }) => {\n\n    const rowData = getRowData( rowIndex );\n\n    return (\n        <div {...getRowProps(rowData, rowIndex, getRowExtraProps)}>\n            {rowData}\n        </div>\n    );\n};\n\nRow.propTypes = {\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func\n};\n\nexport default Row;","import React, { useEffect } from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#startIndex\",\n    \"#endIndex\",\n    \"#rowKeyGetter\",\n    \"#rowDataGetter\"\n];\n\nconst getVisibleRows = (\n    rangeFrom,\n    rangeTo,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    RowComponent\n) => {\n    const result = [];\n    for( let rowKey; rangeFrom < rangeTo; rangeFrom++ ){\n        rowKey = getRowKey ? getRowKey( rangeFrom ) : rangeFrom;\n        result.push(\n            <RowComponent\n                getRowExtraProps={getRowExtraProps}\n                rowIndex={rangeFrom}\n                key={rowKey}\n                getRowData={getRowData}\n            />\n        );\n    }\n    return result;\n};\n\nconst Rows = ({ getRowExtraProps, RowComponent }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    useEffect(() => {\n        API.reportRowsRendered();\n    });\n\n    return getVisibleRows(\n        API.startIndex,\n        API.endIndex,\n        API.rowDataGetter,\n        API.rowKeyGetter,\n        getRowExtraProps,\n        RowComponent\n    );\n};\n\nexport default Rows;","import React, { memo } from \"react\";\nimport useApiPlugin from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#virtualTopOffset\" ];\n\nconst Scroller = ({ Component }) => {\n\n    const { virtualTopOffset } = useApiPlugin( SUBSCRIBE_EVENTS );\n    /*\n        Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n    */\n    return <Component aria-hidden=\"true\" style={{ height: virtualTopOffset, visibility: \"hidden\" }} />;\n};\n\nexport default memo( Scroller );","import React from \"react\";\nimport { css, cx } from \"emotion\";\n\nconst wrapperClass = css`\n    flex: 1 1 auto;\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(wrapperClass,className)} {...props} />;\n\nexport default RowCountWarningContainer;","const commonDefaultProps = {\n    fixedSize: false,\n    rowCount: 0,\n    overscanRowsCount: 4\n};\n\nexport default commonDefaultProps;","import React, { memo, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { css } from \"emotion\";\n\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\n\nimport VariableSizeListStore from \"../models/VariableSizeList\";\nimport FixedSizeListStore from \"../models/FixedSizeList\";\n\nimport ScrollContainer from \"../common/ScrollContainer\";\nimport RowComponentDefault from \"./common/Row\";\nimport Rows from \"./common/Rows\";\n\nimport Scroller from \"../common/Scroller\";\nimport RowCountWarningContainerDefault from \"../common/RowCountWarningContainer\";\n\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\n\n/*\n    flex: 1 1 auto, assuming that table would be used full-stretch mostly\n*/\nconst wrapperClass = css`\n    min-height: 0;\n    flex: 1 1 auto;\n\n    * {\n        box-sizing: border-box;\n    }\n`;\n\nconst List = ({\n    fixedSize,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    rowCount,\n    overscanRowsCount,\n    rowCountWarningsTable,\n    RowCountWarningContainer,\n    RowComponent = RowComponentDefault,\n    dataRef,\n    ...props\n}) => {\n\n    const scrollContainerRef = useRef();\n    const rowsContainerRef = useRef();\n\n    const Store = useStore( fixedSize ? FixedSizeListStore : VariableSizeListStore, dataRef );\n\n    useEffect(() => {\n        Store.merge({\n            rowDataGetter: getRowData,\n            rowKeyGetter: getRowKey,\n            overscanRowsCount,\n            totalRows: rowCount,\n            rowsContainerNode: rowsContainerRef.current,\n            scrollContainerNode: scrollContainerRef.current\n        });\n    });\n\n    return (\n        <Context.Provider value={Store}>\n            { rowCount > 0 ? (\n                <ScrollContainer\n                    className={wrapperClass}\n                    ref={scrollContainerRef}\n                    {...props}\n                >\n                    <Scroller Component=\"div\" />\n                    <div ref={rowsContainerRef}>\n                        <Rows RowComponent={RowComponent} getRowExtraProps={getRowExtraProps} />\n                    </div>\n                </ScrollContainer>\n            ) : rowCountWarningsTable ? (\n                <RowCountWarningContainer>\n                    {rowCountWarningsTable[rowCount]}\n                </RowCountWarningContainer>\n            ) : null }\n        </Context.Provider>\n    );\n};\n\nList.propTypes = {\n    ...commonPropTypes,\n    RowCountWarningContainer: PropTypes.any,\n    rowCountWarningsTable: PropTypes.object\n};\n\nList.defaultProps = {\n    ...commonDefaultProps,\n\n    \n    /*\n        For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n        If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n        memo(observer(RowComponentDefault)) will do the trick.\n    */\n    \n    RowComponent: memo( RowComponentDefault ),\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default memo( List );","import React, { useRef } from \"react\";\nimport List from \"af-virtual-scroll/src/List\";\nimport r from \"lodash/random\";\nimport times from \"lodash/times\";\nimport { css } from \"@emotion/core\";\n\nconst wrapperCss = css`\n    display: flex;\n    flex-flow: column nowrap;\n`;\n\nconst rowCount = 100000;\n\nconst heights = times( rowCount, () => r( 50, 250 ) );\n\nconst getRowData = index => (\n    <div style={{\n        lineHeight: `${heights[index]}px`,\n        borderTop: \"1px solid #666\",\n        background: `hsl(${r(0,360)},${r(30,80)}%,${r(30,80)}%)`\n    }}>\n        row{index}:&nbsp;{heights[index]}px\n    </div>\n);\n\nconst ListWithScrollToRowButton = ({ className }) => {\n\n    const dataRef = useRef();\n\n    const submitHandler = e => {\n        e.preventDefault();\n        const v = e.currentTarget.elements.scrollRow.value;\n        dataRef.current.scrollToRow( +v );\n    };\n\n    return (\n        <div css={wrapperCss} className={className}>\n            <form onSubmit={submitHandler}>\n                <label>\n                    Row:&nbsp;\n                    <input\n                        name=\"scrollRow\"\n                        type=\"number\"\n                        defaultValue=\"0\"\n                    />\n                </label>\n                <button type=\"submit\">\n                    Scroll\n                </button>\n            </form>\n            <List\n                dataRef={dataRef}\n                getRowData={getRowData}\n                rowCount={rowCount}\n            />\n        </div>\n    );\n};\n\nexport default ListWithScrollToRowButton;","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n"],"sourceRoot":""}