{"version":3,"sources":["webpack:///./src/utils/isPositionStickySupported/index.js","webpack:///./src/Context.js","webpack:///./src/utils/useStore/index.js","webpack:///./src/models/createTable.js","webpack:///./src/models/EventEmitter.js","webpack:///./src/models/ListBase.js","webpack:///./src/models/FixedSizeTable.js","webpack:///./src/models/FixedSizeList.js","webpack:///./src/models/VariableSizeList.js","webpack:///./src/models/VariableSizeTable.js","webpack:///./src/utils/extraPropsGetters/index.js","webpack:///./src/Table/common/Row.js","webpack:///./src/Table/common/Cell.js","webpack:///./src/Table/common/TotalsCell.js","webpack:///./src/utils/cx/index.js","webpack:///./src/common/RowCountWarningContainer.js","webpack:///./src/useApi/index.js","webpack:///./src/Table/common/Colgroup.js","webpack:///./src/Table/NonSticky/TableWrapper/index.js","webpack:///./src/Table/common/HeaderCells.js","webpack:///./src/Table/common/Thead.js","webpack:///./src/Table/common/FooterCells.js","webpack:///./src/Table/common/Tfoot.js","webpack:///./src/Table/common/Rows.js","webpack:///./src/Table/common/Tbody.js","webpack:///./src/Table/common/BodyTable.js","webpack:///./src/Table/NonSticky/useColWidthsResizeObserver/index.js","webpack:///./src/common/Scroller.js","webpack:///./src/Table/common/TbodyScroller.js","webpack:///./src/common/HeightProvider.js","webpack:///./src/common/ScrollContainer.js","webpack:///./src/Table/NonSticky/index.js","webpack:///./src/Table/Sticky/index.js","webpack:///./src/commonDefaultProps.js","webpack:///./src/Table/index.js","webpack:///./websiteSrc/examples/table/variableRowHeights.js"],"names":["stickyCssText","map","p","join","once","elStyle","document","createElement","style","cssText","position","includes","createContext","useStore","StoreConstructor","dataRef","finalDataRef","useRef","Store","current","useEffect","destructor","OrderedRowsCache","Uint32Array","TbodyColumnWidthsCache","L","Intl","Collator","getValueForSorting","srcVal","rowIndex","fieldName","defaultValue","getRowData","getCellData","result","reduceRange","totalRows","dataKey","startValue","getNewRes","rowData","res","i","TotalsCachePart","count","sum","average","createTable","BaseClass","constructorCallback","columns","totals","headlessMode","sortColumnIndex","sortDirectionSign","scrollLeft","tbodyColumnWidths","orderedRows","totalsCache","Object","create","refreshTotals","debounce","j","length","refreshTotalsForColumnRaw","refreshSorting","sort","sorter","method","directionSign","fn","compare","subtract","a","b","v1","v2","getSorter","rowDataGetter","emit","on","resetColumnWidthsCache","refreshRowsOrder","scrollToStart","cellDataGetter","curTotals","this","curCachePart","totalType","oldVal","newVal","tmpSum","undefined","add","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Math","process","refreshTotalsForColumn","col","find","c","setSortParams","colIndex","rows","cancel","EventEmitter","_T","_a","eventName","prepend","eventsQueue","that","originalFn","apply","off","arguments","prependListener","prependOnceListener","idx","indexOf","splice","a1","a2","a3","a4","evt","argsArr","argLen","call","Array","removeAllListeners","prototype","removeListener","addListener","getRowDataInitial","Error","ListBase","startIndex","endIndex","virtualTopOffset","widgetScrollHeight","overscanRowsCount","estimatedRowHeight","scrollTop","widgetHeight","widgetWidth","rowKeyGetter","rowsContainerNode","scrollContainerNode","increaseEndIndexIfNeeded","currentVisibleDist","getDistanceBetweenIndexes","updateEndIndex","updateWidgetScrollHeight","updateStartOffset","set","paramName","paramValue","merge","params","k","reportRowsRendered","getVisibleRangeStart","newVisibleStartIndex","remainder","newStartIndex","max","overscanOffset","newEndIndex","min","scrollToRow","index","node","clamp","updateEstimatedRowHeight","firstElementChild","offsetHeight","distance","SegmentsTreeCache","sTree","N","shouldResetInvisibleRowHeights","setVisibleRowsHeights","newHeight","l","r","rowHeightsSum","rowCounter","child","nextElementSibling","parseInt","getAttribute","round","calculateParentsInRange","maxWait","resetCache","reallocateCacheIfNeeded","markResetInvisibleRowHeights","dist","v","nodeIndex","fill","suggestedN","ceil","log2","instance","getPropsGetter","propName","data","getExtraProps","props","extraProps","assign","getRowProps","getCellProps","Row","CellComponent","getRowExtraProps","getCellExtraProps","rowDataIndex","column","columnIndex","visibility","FinalCellComponent","key","propTypes","Cell","render","getEmptyCellData","format","cellData","TotalsCell","cellTotals","formatTotal","summaryType","title","capitalize","cx","baseClass","extraClass","RowCountWarningContainer","className","reducer","x","useApi","subscribeEvents","API","useContext","Context","up","useReducer","useLayoutEffect","commonSubscribeEvents","nonStickySubscribeEvents","concat","memo","useTbodyWidths","useApiPlugin","cols","background","border","width","SUBSCRIBE_EVENTS","TableWrapper","children","marginLeft","aria-colcount","SortDirections","label","data-sortable","aria-colindex","aria-sort","trRef","getCellStyle","clickHandler","useCallback","e","target","onClick","ref","FooterCells","TotalsCellComponent","curTotalsCache","Rows","RowComponent","rangeFrom","rangeTo","getRowKey","rowKey","push","getVisibleRows","tbodyRef","BodyTable","fixedLayout","tableStyle","tableLayout","minWidth","aria-rowcount","useColWidthsResizeObserver","observerRef","O","ResizeObserver","entries","offsetWidth","observe","disconnect","Component","aria-hidden","height","TbodyScroller","el","cloneElement","ScrollContainer","forwardRef","onScroll","reportScrollLeft","scrollHandler","resizeHandler","useResizeObserver","onResize","tabIndex","scrollContainerRef","widthsObserverRef","useMemo","commonDefaultProps","fixedSize","rowCount","Table","rowCountWarningsTable","headless","useStickyIfPossible","FixedSizeTableStore","VariableSizeTableStore","ComponentVariant","isPositionStickySupported","StickyComponent","NonStickyComponent","Provider","value","defaultProps","RowComponentDefault","CellComponentDefault","TotalsCellComponentDefault","RowCountWarningContainerDefault","tableCss","lineHeight","times","num","str","faker","name","findName","rect","VariableRowHeightsTable","css"],"mappings":"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","file":"27.b6c4c65ea39aa2c11d75.js","sourcesContent":["import once from \"lodash/once\";\n\nconst stickyCssText = [ \"\", \"-webkit-\", \"-ms-\" ].map( p => `position:${p}sticky` ).join( \";\" );\n\nconst isPositionStickySupported = () => {\n    const elStyle = document.createElement( \"a\" ).style;\n    elStyle.cssText = stickyCssText;\n    \n    return elStyle.position.includes( \"sticky\" );\n};\n\n/*\n    'once' is needed to use this function frequently without perf issues.\n*/\nexport default once( isPositionStickySupported );","import { createContext } from \"react\";\n\nexport default createContext();","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef ) => {\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !Store || !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    useEffect(() => () => {\n        Store.destructor();\n    }, [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","import debounce from \"lodash/debounce\";\nimport subtract from \"lodash/subtract\";\nimport add from \"lodash/add\";\n\nconst OrderedRowsCache = Uint32Array;\nconst TbodyColumnWidthsCache = Uint32Array;\n\nconst REFRESH_SORT_DEBOUNCE_INTERVAL = 500;\n\nconst L = new Intl.Collator();\n\nconst getValueForSorting = ( srcVal, rowIndex, fieldName, defaultValue, getRowData, getCellData ) => {\n    const result = getRowData( srcVal );\n    if( result ){\n        return getCellData ? getCellData( result, rowIndex ) : result[ fieldName ];\n    }\n    return defaultValue;\n}\n\nconst getSorter = ( getRowData, fieldName, method, getCellData, directionSign ) => {\n    const fn = method === \"locale\" ? L.compare : subtract;\n    const defaultValue = method === \"locale\" ? \"\" : 0;\n\n    return ( a, b, i ) => {\n        const v1 = getValueForSorting( a, i, fieldName, defaultValue, getRowData, getCellData );\n        const v2 = getValueForSorting( b, i, fieldName, defaultValue, getRowData, getCellData );\n        return fn( v1, v2 ) * directionSign;\n    };\n};\n\nconst reduceRange = ( totalRows, dataKey, getRowData, getCellData, startValue, getNewRes ) => {\n    let res = startValue;\n    for( let i = 0, rowData, cellData; i < totalRows; i++ ){\n        rowData = getRowData( i );\n        cellData = getCellData ? getCellData( rowData, i ) : rowData[ dataKey ];\n        res = getNewRes( res, cellData );\n    }\n    return res;\n}\n\n/*\n    We could use simple object literal,\n    but constructors with stable-order this initialization enforce \"hidden-classes\" v8 optimization\n*/\nclass TotalsCachePart {\n    count = 0;\n    sum = 0;\n    average = 0.0;\n};\n\n/*\n    can't extend from both FixedSizeList and VariableSizeList, so exporting compositor\n*/\nconst createTable = ( BaseClass, constructorCallback ) => class extends BaseClass {\n\n    columns = [];\n    totals = {};\n    headlessMode = false;\n\n    sortColumnIndex = -1;\n    sortDirectionSign = 1;\n\n    scrollLeft = 0;\n    tbodyColumnWidths = null;\n    orderedRows = new OrderedRowsCache( 0 );\n\n    /*\n        We do not want to recalculate totals too often, so caching them in object by column dataKey\n    */\n    totalsCache = Object.create( null );\n\n\n    /*\n        TODO:\n            make this call throttled\n    */\n\n    refreshTotalsForColumnRaw( dataKey, cellDataGetter ){\n        const curTotals = this.totals && this.totals[ dataKey ];\n        if( curTotals ){\n            let curCachePart = this.totalsCache[ dataKey ];\n\n            if( !curCachePart ){\n                curCachePart = this.totalsCache[ dataKey ] = new TotalsCachePart();\n            }\n            \n            for( let j = 0, totalType, oldVal, newVal, tmpSum; j < curTotals.length; j++ ){\n                totalType = curTotals[ j ];\n                oldVal = curCachePart[ totalType ];\n                switch( totalType ){\n                    case \"count\":\n                        newVal = this.totalRows;\n                        break;\n                    case \"sum\":\n                    case \"average\":\n                        if( tmpSum === undefined ){\n                            tmpSum = reduceRange( this.totalRows, dataKey, this.rowDataGetter, cellDataGetter, 0, add );\n                        }\n                        newVal = totalType === \"sum\" ? tmpSum : tmpSum / this.totalRows;\n                        break;\n                    case \"min\":\n                    case \"max\":\n                        newVal = reduceRange(\n                            this.totalRows,\n                            dataKey,\n                            this.rowDataGetter,\n                            cellDataGetter,\n                            totalType === \"min\" ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER,\n                            Math[totalType]\n                        );\n                        break;\n                    default:\n                        if( process.env.NODE_ENV !== \"production\" ){\n                            throw new Error( `Wrong total type: ${totalType}` );\n                        }\n                }\n  \n                if( oldVal !== newVal ){\n                    curCachePart[ totalType ] = newVal;\n                    this.emit( \"totals-calculated\" );\n                }\n            }\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.log( `Asked to recalculate totals for: ${dataKey}; doing nothing;` );\n        }\n        return this;\n    }\n\n    refreshTotalsForColumn( dataKey ){\n        const col = this.columns.find( c => c.dataKey === dataKey );\n        if( col ){\n            this.refreshTotalsForColumnRaw( dataKey, col.getCellData );\n        }\n        return this;\n    }\n\n    refreshTotals = debounce(() => {\n        for( let j = 0, dataKey, getCellData; j < this.columns.length; j++ ){\n            ({ dataKey, getCellData } = this.columns[ j ]);\n            this.refreshTotalsForColumnRaw( dataKey, getCellData );\n        }\n        return this;\n    }, 100 );\n\n    setSortParams( colIndex, sortDirectionSign ){\n        if( this.sortColumnIndex !== colIndex || sortDirectionSign !== this.sortDirectionSign ){\n            this.sortColumnIndex = colIndex;\n            this.sortDirectionSign = sortDirectionSign;\n            this.emit( \"sort-params-changed\" );\n        }\n    }\n\n    refreshSorting = debounce(() => {\n        if( this.sortColumnIndex > -1 && this.totalRows > 0 ){\n            const { sort, dataKey, getCellData } = this.columns[ this.sortColumnIndex ];\n            if( sort ){\n                const sorter = getSorter( this.rowDataGetter, dataKey, sort, getCellData, this.sortDirectionSign );\n                this.orderedRows.sort( sorter );\n                this.emit( \"#rowsOrder\" );\n            }\n        }\n    }, REFRESH_SORT_DEBOUNCE_INTERVAL );\n\n    refreshRowsOrder(){\n        if( this.orderedRows.length !== this.totalRows ){\n            const rows = this.orderedRows = new OrderedRowsCache( this.totalRows );\n            for( let j = 1; j < rows.length; j++ ){\n                rows[ j ] = j;\n            }\n        }\n        return this;\n    }\n\n    resetColumnWidthsCache(){\n        this.tbodyColumnWidths = new TbodyColumnWidthsCache( this.columns.length );\n    }\n\n    constructor(){\n        super();\n\n        this\n            .on( \"#columns\", this.resetColumnWidthsCache )\n            .on( \"#columns\", this.refreshTotals )\n            .on( \"#columns\", this.refreshSorting )\n            .on( \"#totalRows\", this.refreshRowsOrder )\n            .on( \"#totalRows\", this.refreshSorting )\n            .on( \"#totalRows\", this.refreshTotals )\n            .on( \"sort-params-changed\", this.refreshSorting )\n            .on( \"#rowDataGetter\", this.refreshSorting )\n            .on( \"#rowDataGetter\", this.refreshTotals )\n            .on( \"#rowsOrder\", this.scrollToStart )\n            .on( \"#totals\", this.refreshTotals )\n        \n            .refreshRowsOrder();\n\n        if( constructorCallback ){\n            constructorCallback( this );\n        }\n    }\n\n    destructor(){\n        this.refreshSorting.cancel();\n        this.refreshTotals.cancel();\n        super.destructor();\n    }\n}\n\nexport default createTable;","class EventEmitter {\n\n    _T = Object.create( null );\n\n    _a( eventName, fn, prepend, once ){\n\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !eventName || !fn ){\n                console.log( eventName, fn );\n                throw new Error( \"Wrong eventName/fn provided\" );\n            }\n        }\n\n        let eventsQueue = this._T[ eventName ];\n        \n        if( once ){\n            const that = this,\n                originalFn = fn;\n\n            /*\n                when using ...args and arrow func, babel is making unnecessary arguments copy.\n                Going old-school here for perf\n            */\n            fn = function(){\n                originalFn.apply( that.off( eventName, fn ), arguments );\n            }\n        }\n    \n        if( !eventsQueue ){\n            eventsQueue = this._T[ eventName ] = [];\n        }\n    \n        eventsQueue[ prepend ? \"unshift\" : \"push\" ]( fn );\n        return this;\n    }\n\n    on( eventName, fn ){\n        return this._a( eventName, fn, false, false );\n    }\n\n    prependListener( eventName, fn ){\n        return this._a( eventName, fn, true, false );\n    }\n\n    prependOnceListener( eventName, fn ){\n        return this._a( eventName, fn, true, true );\n    }\n\n    once( eventName, fn ){\n        return this._a( eventName, fn, false, true );\n    }\n\n    off( eventName, fn ){\n        const eventsQueue = this._T[ eventName ];\n        if( eventsQueue ){\n            const idx = eventsQueue.indexOf( fn );\n            if( idx !== -1 ){\n                eventsQueue.splice( idx, 1 );\n            }\n        }\n        return this;\n    }\n\n    emit( eventName, a1, a2, a3, a4 ){\n        const eventsQueue = this._T[ eventName ];\n        if( eventsQueue ){\n            for( let j = 0, i, evt, argLen = arguments.length, argsArr; j < eventsQueue.length; j++ ){\n                evt = eventsQueue[ j ];\n                switch( argLen ){\n                    case 1: evt.call( this ); break;\n                    case 2: evt.call( this, a1 ); break;\n                    case 3: evt.call( this, a1, a2 ); break;\n                    case 4: evt.call( this, a1, a2, a3 ); break;\n                    case 5: evt.call( this, a1, a2, a3, a4 ); break;\n                    default:\n                        if( !argsArr ){\n                            for( i = 1, argsArr = new Array( argLen - 1 ); i < argLen; i++ ){\n                                argsArr[ i - 1 ] = arguments[ i ];\n                            }\n                        }\n                        evt.apply( this, argsArr );\n                        break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    removeAllListeners( eventName ){\n        if( eventName ){\n            this._T[ eventName ] = [];\n        }\n        else{\n            this._T = Object.create( null );\n        }\n        return this;\n    }\n}\n\nEventEmitter.prototype.removeListener = EventEmitter.prototype.off;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\nexport default EventEmitter;","import clamp from \"lodash/clamp\";\nimport EventEmitter from \"./EventEmitter\";\nimport debounce from \"lodash/debounce\";\n\nconst getRowDataInitial = () => {\n    throw new Error( \"getRowData must be provided\" );\n};\n\nconst END_INDEX_CHECK_INTERVAL = 400;\nconst DEFAULT_ESTIMATED_ROW_HEIGHT = 16;\n\nclass ListBase extends EventEmitter {\n\n    totalRows = 0;\n    startIndex = 0;\n    endIndex = 0;\n\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n\n    overscanRowsCount = 0;\n    estimatedRowHeight = DEFAULT_ESTIMATED_ROW_HEIGHT;\n\n    scrollTop = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n\n    rowKeyGetter = undefined;\n    rowDataGetter = getRowDataInitial;\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    set( paramName, paramValue ){\n\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.hasOwnProperty( paramName ) ){\n                throw new Error( `Trying to merge key, which does not exist: ${paramName}` );\n            }\n        }\n\n        if( this[ paramName ] !== paramValue ){\n            this[ paramName ] = paramValue;\n            this.emit( `#${paramName}` );\n        }\n\n        return this;\n    }\n    \n    merge( params ){\n        for( let k in params ){\n            this.set( k, params[ k ] );\n        }\n        return this;\n    }\n    \n    constructor(){\n        super();\n        \n        if( process.env.NODE_ENV !== \"production\" ){\n            const absentMethods = [\n                \"updateWidgetScrollHeight\",\n                \"getDistanceBetweenIndexes\",\n                \"getVisibleRangeStart\"\n            ].filter( fn => !this[ fn ] );\n\n            if( absentMethods.length ){\n                throw new Error( `Absent methods: ${absentMethods.join( \",\" )}` );\n            }\n        }\n\n        this\n            .on( \"#totalRows\", this.updateWidgetScrollHeight )\n            .on( \"#totalRows\", this.updateEndIndex )\n            .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\n            .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel )\n            .on( \"#scrollTop\", this.updateStartOffset )\n            .on( \"#overscanRowsCount\", this.updateStartOffset )\n            .on( \"#widgetHeight\", this.updateEndIndex )\n            .on( \"#startIndex\", this.updateEndIndex );\n    }\n\n    /*\n        Column heights may change during scroll/width-change\n    */\n    increaseEndIndexIfNeeded = debounce(() => {\n        const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n        return this;\n    }, END_INDEX_CHECK_INTERVAL );\n\n    destructor(){\n        this.increaseEndIndexIfNeeded.cancel();\n        this.removeAllListeners();\n    }\n    \n    reportRowsRendered(){\n        this.emit( \"rows-rendered\" );\n    }\n\n    updateStartOffset(){\n        const { scrollTop, overscanRowsCount } = this;\n        const [ newVisibleStartIndex, remainder ] = this.getVisibleRangeStart( scrollTop );\n        const newStartIndex = Math.max( 0, newVisibleStartIndex - overscanRowsCount );\n        const overscanOffset = this.getDistanceBetweenIndexes( newStartIndex, newVisibleStartIndex );\n                \n        return this\n            .set( \"virtualTopOffset\", scrollTop - remainder - overscanOffset )\n            .set( \"startIndex\", newStartIndex );\n    }\n\n    updateEndIndex(){\n        const [ newEndIndex ] = this.getVisibleRangeStart( this.scrollTop + this.widgetHeight );\n        /*\n            getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return this.set( \"endIndex\", Math.min( newEndIndex + 1 + this.overscanRowsCount, this.totalRows ) );\n    }\n\n    scrollToRow( index ){\n        const node = this.scrollContainerNode;\n        if( node ){\n            index = clamp( index, 0, this.totalRows );\n            node.scrollTop = this.getDistanceBetweenIndexes( 0, index );\n        }\n        return this;    \n    }\n\n    scrollToStart(){\n        return this.scrollToRow( 0 );\n    }\n};\n\nexport default ListBase;","import createTable from \"./createTable\";\nimport FixedSizeList from \"./FixedSizeList\";\n\nexport default createTable( FixedSizeList );","import ListBase from \"./ListBase\";\n\nclass FixedSizeList extends ListBase {\n    \n    updateWidgetScrollHeight(){\n        return this.set( \"widgetScrollHeight\", this.estimatedRowHeight * this.totalRows );\n    }\n\n    updateEstimatedRowHeight(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { firstElementChild } = node;\n            if( firstElementChild ){\n                this.set( \"estimatedRowHeight\", node.firstElementChild.offsetHeight );\n            }\n        }\n    }\n\n    getVisibleRangeStart( distance ){\n        const { estimatedRowHeight } = this;\n        return [ distance / estimatedRowHeight | 0, distance % estimatedRowHeight ];\n    }\n\n    constructor(){\n        super();\n\n        this\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"#widgetWidth\", this.updateEstimatedRowHeight );\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        return this.estimatedRowHeight * ( endIndex - startIndex );\n    }\n};\n\nexport default FixedSizeList;","import ListBase from \"./ListBase\";\nimport debounce from \"lodash/debounce\";\n\n// Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\nconst SegmentsTreeCache = Uint32Array;\n\n/*\n    This constant is used for 2 reasons:\n        * Math.log2( 1 ) is 0, which is not correct for cache size calculation\n        * We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_OFFSET = 32;\n\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 50;\nconst ROW_MEASUREMENT_DEBOUNCE_MAXWAIT = 150; \n\nclass VariableSizeList extends ListBase {\n\n    /*\n        Two vars for non-recursive segments tree;\n        Could just make [ 0, 0 ], but want to keep type of heightsCache always of same type.\n    */\n    sTree = new SegmentsTreeCache( 2 );\n    N = 1;\n\n    /*\n        When all row heights are different,\n        we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n        basing on what we know: heights between startIndex and endIndex.\n        Using simple average by default.\n    */\n    shouldResetInvisibleRowHeights = true;\n\n    markResetInvisibleRowHeights(){\n        this.shouldResetInvisibleRowHeights = true;\n    }\n\n    updateWidgetScrollHeight(){\n        /* In segments tree 1 node is always sum of all elements */\n        return this.set( \"widgetScrollHeight\", this.sTree[ 1 ] );\n    }\n\n    calculateParentsInRange( startIndex, endIndex ){\n        const { sTree, N } = this;\n    \n        for( endIndex += N, startIndex += N; endIndex >>= 1; ){\n            for( let i = startIndex >>= 1; i <= endIndex; i++ ){\n                sTree[ i ] = sTree[ i << 1 ] + sTree[ i << 1 | 1 ];\n            }\n        }\n\n        return this;\n    }\n\n    /*\n        TODO: maybe some react-like performUnitOfWork logic is needed here?\n    */\n    setVisibleRowsHeights = debounce(() => {\n        const node = this.rowsContainerNode;\n\n        if( node ){\n            const { sTree, N } = this;\n            \n            let l = -1,\n                r = -1,\n                rowHeightsSum = 0,\n                rowCounter = 0;\n\n            /*\n                Some benchmarks inspire me to use nextElementSibling\n                https://jsperf.com/nextsibling-vs-childnodes-increment/2\n            */\n            for( let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++ ){\n                \n                /*\n                    * aria-rowindex is counted from 1 according to w3c spec;\n                    * parseInt with radix is 2x faster, then +, -, etc.\n                      https://jsperf.com/number-vs-parseint-vs-plus/116\n                */\n                index = parseInt( child.getAttribute( \"aria-rowindex\" ), 10 ) - 1;\n\n                if( process.env.NODE_ENV !== \"production\" && Number.isNaN( index ) ){\n                    throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                }\n\n                newHeight = child.offsetHeight;\n                rowHeightsSum += newHeight;\n\n                if( sTree[ N + index ] !== newHeight ){\n                    // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n                    sTree[ N + index ] = newHeight;\n                    \n                    if( l === -1 ){\n                        l = index;\n                    }\n                    \n                    r = index;\n                }\n            }\n \n            if( l !== -1 ){\n                if( process.env.NODE_ENV !== \"production\" ){\n                    console.log( \"Updating heights in range: %d - %d\", l, r );\n                }\n\n                if( this.shouldResetInvisibleRowHeights ){\n                    this.set( \"estimatedRowHeight\", Math.round( rowHeightsSum / rowCounter ) );\n                    this.shouldResetInvisibleRowHeights = false;\n                }\n                else{\n                    this\n                        .calculateParentsInRange( l, r )\n                        .updateWidgetScrollHeight();\n                }\n            }\n        }\n\n        return this;\n    }, ROW_MEASUREMENT_DEBOUNCE_INTERVAL, { maxWait: ROW_MEASUREMENT_DEBOUNCE_MAXWAIT });\n    \n    getVisibleRangeStart( dist ){\n        const { sTree, N } = this;\n        let nodeIndex = 1, v;\n\n        while( nodeIndex < N ){\n            v = sTree[ nodeIndex <<= 1 ];\n            if( dist >= v ){\n                dist -= v;\n                nodeIndex |= 1;\n            }\n        }\n\n        return [ nodeIndex - N, dist ];\n    }\n\n    resetCache(){\n        const { sTree, estimatedRowHeight, N, totalRows } = this;\n        sTree.fill( estimatedRowHeight, N, N + totalRows );\n\n        /*\n            Trees are not always ideally allocated, gaps are possible.\n            Classical way for calculating parents is much simpler,\n            but can do much more work(summing zeros) in such conditions. Commented classic algo:\n    \n            for( let i = N + totalRows >> 1, j; i > 0; --i ){\n                j = i << 1;\n                sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n            }\n        */\n        return this.calculateParentsInRange( 0, totalRows );\n    }\n\n    reallocateCacheIfNeeded(){\n        const suggestedN = this.totalRows ? 2 ** Math.ceil( Math.log2( this.totalRows + MIN_TREE_CACHE_OFFSET ) ) : 1;\n\n        if( this.N !== suggestedN ){\n            this.N = suggestedN;\n            this.sTree = new SegmentsTreeCache( suggestedN * 2 );\n        }\n\n        return this;\n    }\n\n    constructor(){\n        super();\n\n        this\n            .prependListener( \"#totalRows\", this.resetCache )\n            .prependListener( \"#totalRows\", this.reallocateCacheIfNeeded )\n            .on( \"#estimatedRowHeight\", this.resetCache )\n            .on( \"#estimatedRowHeight\", this.updateWidgetScrollHeight )\n            .on( \"rows-rendered\", this.setVisibleRowsHeights )\n            .on( \"#widgetWidth\", this.markResetInvisibleRowHeights )\n            .on( \"#widgetWidth\", this.setVisibleRowsHeights );\n    }\n\n    destructor(){\n        this.setVisibleRowsHeights.cancel();\n        super.destructor();\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        const { sTree, N } = this;\n        let res = 0;\n\n        for( startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1 ){\n            if( startIndex & 1 ){\n                res += sTree[ startIndex++ ];\n            }\n\n            if( endIndex & 1 ){\n                res += sTree[ --endIndex ]; \n            }\n        };\n\n        return res; \n    }\n};\n\nexport default VariableSizeList;","import createTable from \"./createTable\";\nimport VariableSizeList from \"./VariableSizeList\";\n\nexport default createTable( VariableSizeList, instance => {\n    instance.prependListener( \"#rowsOrder\", instance.resetCache );\n});","const getPropsGetter = propName => ( data, index, getExtraProps ) => {\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    const props = {\n        [propName]: index + 1\n    };\n\n    if( getExtraProps ){\n        const extraProps = getExtraProps( data, index );\n        if( extraProps ){\n            if( process.env.NODE_ENV !== \"production\" ){\n                if( extraProps.hasOwnProperty( propName ) ){\n                    throw new Error( `getExtraProps must not override ${propName}` );\n                }\n            }\n            Object.assign( props, extraProps );\n        }\n    }\n\n    return props;\n}\n\nexport const getRowProps = getPropsGetter( \"aria-rowindex\" );\nexport const getCellProps = getPropsGetter( \"aria-colindex\" );","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst Row = ({ columns, CellComponent, getRowData, getRowExtraProps, getCellExtraProps, rowDataIndex, rowIndex }) => {\n\n    const rowData = getRowData( rowDataIndex );\n\n    return (\n        <tr {...getRowProps(rowData,rowDataIndex,getRowExtraProps)}>\n            {columns.map(( column, columnIndex ) => {\n                if( column.visibility === \"hidden\" ){\n                    return null;\n                }\n\n                const FinalCellComponent = column.CellComponent || CellComponent;\n\n                return (\n                    <FinalCellComponent\n                        key={column.dataKey}\n                        rowData={rowData}\n                        rowIndex={rowIndex}\n                        column={column}\n                        columnIndex={columnIndex}\n                        getCellExtraProps={column.getCellExtraProps||getCellExtraProps}\n                    />\n                );\n            })}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.oneOfType([ PropTypes.func, PropTypes.node ]).isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    rowDataIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getCellProps } from \"../../utils/extraPropsGetters\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, column, columnIndex, getCellExtraProps }) => {\n    const { render, getEmptyCellData, dataKey, format, getCellData } = column;\n\n    let cellData = rowData && ( getCellData ? getCellData( rowData, rowIndex ) : rowData[ dataKey ] );\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else{\n        if( format ){\n            cellData = format( cellData, rowData );\n        }\n        if( render ){\n            cellData = render( cellData, rowData, column );\n        }\n    }\n\n    return (\n        <td {...getCellProps(rowData,columnIndex,getCellExtraProps)}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    rowIndex: PropTypes.number.isRequired,\n    columnIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Cell;","import React from \"react\";\nimport capitalize from \"lodash/capitalize\";\n\nconst TotalsCell = ({ cellTotals, totalsCache, formatTotal }) => {\n\n    if( !cellTotals || !totalsCache ){\n        return null;\n    }\n\n    if( cellTotals.length === 1 ){\n        const summaryType = cellTotals[ 0 ];\n        const res = totalsCache[ summaryType ];\n        return (\n            <div title={summaryType}>\n                {formatTotal?formatTotal(res):res}\n            </div>\n        );\n    }\n\n    return cellTotals.map( summaryType => {\n        const res = totalsCache[ summaryType ];\n        return res !== undefined ? (\n            <div key={summaryType}>\n                {capitalize(summaryType)}:&nbsp;{formatTotal?formatTotal(res):res}\n            </div>\n        ) : null;\n    });\n};\n\nexport default TotalsCell;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nexport default cx;","import React from \"react\";\nimport cx from \"../utils/cx\"\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(\"afvscr-row-count-warning-container\",className)} {...props} />;\n\nexport default RowCountWarningContainer;","import { useContext, useLayoutEffect, useReducer } from \"react\";\nimport Context from \"../Context\";\n\nconst reducer = x => x + 1;\n\n/*\n\tTODO:\n\t\twhy useEffect does not properly update colgroup of tbody, when rowcount changes from 0 to positive value?\n*/\n\nconst useApi = subscribeEvents => {\n\n\tconst API = useContext( Context );\n\n\tconst [, up] = useReducer( reducer, 0 );\n    \n\tuseLayoutEffect(() => {\n\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\tAPI.on( subscribeEvents[ j ], up );\n\t\t}\n\t\treturn () => {\n\t\t\tfor( let j = 0; j < subscribeEvents.length; j++ ){\n\t\t\t\tAPI.off( subscribeEvents[ j ], up );\n\t\t\t}\n\t\t};\n\t}, subscribeEvents );\n\n\treturn API;\n};\n\nexport default useApi;\n","import React, { memo } from \"react\";\nimport useApiPlugin from \"../../useApi\";\n\nconst commonSubscribeEvents = [ \"#columns\" ];\nconst nonStickySubscribeEvents = commonSubscribeEvents.concat( \"tbody-column-widths-changed\" );\n\nconst Colgroup = ({ useTbodyWidths }) => {\n\n    const { columns, tbodyColumnWidths } = useApiPlugin( useTbodyWidths ? nonStickySubscribeEvents : commonSubscribeEvents );\n\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }, j, cols ) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width: useTbodyWidths ? tbodyColumnWidths[ j ] : width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default memo( Colgroup );","import React from \"react\";\nimport useApi from \"../../../useApi\";\nimport Colgroup from \"../../common/Colgroup\";\nimport sum from \"lodash/sum\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"#scrollLeft\",\n    \"#widgetWidth\",\n    \"tbody-column-widths\"\n];\n\nconst TableWrapper = ({ children, ...props }) => {\n\n    const { scrollLeft, columns, tbodyColumnWidths } = useApi( SUBSCRIBE_EVENTS );\n\n    const style = {\n        /* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */\n        marginLeft: -scrollLeft,\n\n        /* TODO: maybe box-sizing:border-box; is needed here? */\n        width: sum( tbodyColumnWidths )\n    };\n\n    return (\n        <table {...props} style={style} aria-colcount={columns.length}>\n            <Colgroup useTbodyWidths />\n            {children}\n        </table>\n    );\n};\n\nexport default TableWrapper;","import React, { memo } from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"sort-params-changed\"\n];\n\nconst SortDirections = {\n    \"1\": \"ascending\",\n    \"-1\": \"descending\"\n};\n\nconst HeaderCells = () => {\n\n    const { columns, sortColumnIndex, sortDirectionSign } = useApi( SUBSCRIBE_EVENTS );\n\n    return columns.map(({ dataKey, title, sort, label, visibility }, j ) => visibility === \"hidden\" ? null : (\n        <th\n            key={dataKey}\n            title={title}\n            data-sortable={sort?\"\":undefined}\n            aria-colindex={j+1}\n            aria-sort={sortColumnIndex!==j?\"none\":SortDirections[sortDirectionSign]}\n        >\n            {label}\n        </th>\n    ));\n};\n\nexport default memo( HeaderCells );","import React, { useCallback, memo } from \"react\";\nimport HeaderCells from \"./HeaderCells\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [];\n\nconst Thead = ({ trRef, getCellStyle, ...props }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const clickHandler = useCallback( e => {\n\n        const colIndex = parseInt( e.target.getAttribute( \"aria-colindex\" ), 10 ) - 1;\n\n        if( process.env.NODE_ENV !== \"production\" && Number.isNaN( colIndex ) ){\n            throw new Error( \"colIndex attr missing\" );\n        }\n\n        if( API.columns[ colIndex ].sort ){\n            const directionSign = e.target.getAttribute( \"aria-sort\" ) === \"ascending\" ? -1 : 1;\n            API.setSortParams( colIndex, directionSign );\n        }\n    }, []);\n\n    return (\n        <thead {...props} onClick={clickHandler}>\n            <tr ref={trRef}>\n                <HeaderCells />\n            </tr>\n        </thead>\n    );\n};\n\nexport default memo( Thead );","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#columns\",\n    \"#totals\",\n    \"totals-calculated\"\n];\n\nconst FooterCells = ({ TotalsCellComponent }) => {\n\n    const { columns, totals, totalsCache } = useApi( SUBSCRIBE_EVENTS );\n\n    return columns.map(({ dataKey, formatTotal, visibility }, j ) => {\n\n        if( visibility === \"hidden\" ){\n            return null;\n        }\n\n        const curTotals = totals[ dataKey ];\n        const curTotalsCache = totalsCache[ dataKey ];\n\n        return (\n            <td key={dataKey} aria-colindex={j+1}>\n                <TotalsCellComponent\n                    cellTotals={curTotals}\n                    totalsCache={curTotalsCache}\n                    formatTotal={formatTotal}\n                />\n            </td>\n        );\n    });\n};\n\nFooterCells.propTypes = {\n    TotalsCellComponent: PropTypes.any.isRequired\n}\n\nexport default memo( FooterCells );","import React, { memo } from \"react\";\nimport FooterCells from \"./FooterCells\";\n\nconst Tfoot = ({ className, trRef, TotalsCellComponent }) => (\n    <tfoot className={className}>\n        <tr ref={trRef}>\n            <FooterCells TotalsCellComponent={TotalsCellComponent} />\n        </tr>\n    </tfoot>\n);\n\nexport default memo( Tfoot );","import React, { useEffect } from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#startIndex\",\n    \"#endIndex\",\n    \"#columns\",\n    \"#rowsOrder\",\n    \"#rowKeyGetter\",\n    \"#rowDataGetter\"\n];\n\nconst getVisibleRows = (\n    orderedRows,\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey, idx; rangeFrom < rangeTo; rangeFrom++ ){\n        idx = orderedRows[ rangeFrom ];\n        rowKey = getRowKey ? getRowKey( idx ) : idx;\n        result.push(\n            <RowComponent\n                getRowExtraProps={getRowExtraProps}\n                getCellExtraProps={getCellExtraProps}\n                rowIndex={rangeFrom}\n                rowDataIndex={idx}\n                key={rowKey}\n                columns={columns}\n                getRowData={getRowData}\n                CellComponent={CellComponent}\n            />\n        );\n    }\n    return result;\n};\n\nconst Rows = ({ getRowExtraProps, getCellExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    useEffect(() => {\n        API.reportRowsRendered();\n    });\n\n    return getVisibleRows(\n        API.orderedRows,\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        API.rowDataGetter,\n        API.rowKeyGetter,\n        getRowExtraProps,\n        getCellExtraProps,\n        RowComponent,\n        CellComponent\n    );\n};\n\nexport default Rows;","import React, { memo } from \"react\";\nimport Rows from \"./Rows\";\n\nconst Tbody = ({\n    getRowExtraProps,\n    getCellExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent\n}) => (\n    <tbody ref={tbodyRef}>\n        <Rows\n            getRowExtraProps={getRowExtraProps}\n            getCellExtraProps={getCellExtraProps}\n            RowComponent={RowComponent}\n            CellComponent={CellComponent}\n        />\n    </tbody>\n);\n\nexport default memo( Tbody );","import React from \"react\";\nimport useApi from \"../../useApi\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#totalRows\",\n    \"#columns\"\n];\n\nconst BodyTable = ({ fixedLayout, ...props }) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const tableStyle = {\n        tableLayout: fixedLayout ? \"fixed\" : \"auto\",\n        minWidth: \"100%\"\n    };\n    \n    return (\n        <table\n            {...props}\n            aria-rowcount={API.totalRows}\n            style={tableStyle}\n            aria-colcount={API.columns.length}\n        />\n    );\n};\n\nexport default BodyTable;","import { useRef, useEffect } from \"react\";\n\nconst useColWidthsResizeObserver = API => {\n\n    const observerRef = useRef();\n    const trRef = useRef();\n\n    let O = observerRef.current;\n\n    if( !O ){\n        O = observerRef.current = new ResizeObserver( entries => {\n            for( let j = 0, colIndex; j < entries.length; j++ ){\n                const { target } = entries[ j ];\n                colIndex = parseInt( target.getAttribute( \"aria-colindex\" ) );\n                API.tbodyColumnWidths[ colIndex - 1 ] = Math.round( target.offsetWidth );\n            }\n            API.emit( \"tbody-column-widths-changed\" );\n        });\n    }\n\n    useEffect(() => {\n        if( trRef.current ){\n            for( let node = trRef.current.firstElementChild; node; node = node.nextElementSibling ){\n                O.observe( node );\n            }\n            return () => {\n                O.disconnect();\n            };\n        }\n    }, [ trRef.current ]);\n\n    return trRef;\n};\n\nexport default useColWidthsResizeObserver;","import React, { memo } from \"react\";\nimport useApiPlugin from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#virtualTopOffset\" ];\n\nconst Scroller = ({ Component }) => {\n\n    const { virtualTopOffset } = useApiPlugin( SUBSCRIBE_EVENTS );\n    /*\n        Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n    */\n    return <Component className=\"afvscr-scroller\" aria-hidden=\"true\" style={{ height: virtualTopOffset }} />;\n};\n\nexport default memo( Scroller );","import React from \"react\";\nimport Scroller from \"../../common/Scroller\";\n\n/*\n    According to specs, tr must always be inside tbody, thead or tfoot                \n*/\nconst TbodyScroller = () => (\n    <tbody className=\"afvscr-scroller\" aria-hidden=\"true\">\n        <Scroller Component=\"tr\" />\n    </tbody>\n);\n\nexport default TbodyScroller;","import React, { cloneElement, memo } from \"react\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [ \"#widgetScrollHeight\" ];\n\nconst el = <div aria-hidden=\"true\" className=\"afvscr-height-provider\" />;\n\nconst HeightProvider = () => {\n\n    const { widgetScrollHeight: height } = useApi( SUBSCRIBE_EVENTS );\n\n    const props = {\n        style: {\n            height\n        }\n    };\n\n    return cloneElement( el, props );\n};\n\nexport default memo( HeightProvider );","import React, { forwardRef, useCallback } from \"react\";\nimport useResizeObserver from \"use-resize-observer\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\n\nconst SUBSCRIBE_EVENTS = [];\n\nconst ScrollContainer = forwardRef(({\n    className,\n    children,\n    onScroll,\n    reportScrollLeft,\n    ...props\n}, ref ) => {\n\n    const API = useApi( SUBSCRIBE_EVENTS );\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.set( \"scrollTop\", scrollTop );\n        if( reportScrollLeft ){\n            API.set( \"scrollLeft\", scrollLeft );\n        }\n        if( onScroll ){\n            onScroll( e );\n        }\n    }, [ onScroll, reportScrollLeft ]);\n\n    const resizeHandler = useCallback(({ width, height }) => {\n        API.set( \"widgetHeight\", height ).set( \"widgetWidth\", width );\n    }, []);\n\n    useResizeObserver({ ref, onResize: resizeHandler });\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n    */\n    return (\n        <div tabIndex=\"0\" className={cx(\"afvscr-scroll-container\",className)} ref={ref} onScroll={scrollHandler} {...props}>\n            <HeightProvider />\n            {children}\n        </div>\n    );\n});\n\nexport default ScrollContainer;","import React, { memo, useMemo } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport useApi from \"../../useApi\";\nimport TableWrapper from \"./TableWrapper\";\n\nimport Thead from \"../common/Thead\";\nimport Tfoot from \"../common/Tfoot\";\nimport Tbody from \"../common/Tbody\";\nimport BodyTable from \"../common/BodyTable\";\n\nimport useColWidthsResizeObserver from \"./useColWidthsResizeObserver\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport cx from \"../../utils/cx\";\n\nconst subscribeEvents = [\n    \"#headlessMode\",\n    \"#totals\"\n];\n\nconst NonSticky = ({\n    className,\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    fixedLayout,\n    onScroll,\n    ...props\n}) => {\n\n    const API = useApi( subscribeEvents );\n\n    const { headlessMode, totals } = API;\n\n    /*\n        Hidden tfoot & thead are needed to 'hold' widths of tbody columns no to be narrower than real thead/tfoot\n        and notify model about columns width changes.\n        There are 3 tables rendered in this mode, so their column widths need to be synced somehow.\n    */\n    const widthsObserverRef = useColWidthsResizeObserver( API );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( headlessMode && !totals ){\n            console.warn( \"NonSticky table is rendered without headers and footers. This is not ok.\" )\n        }\n    }\n\n    return (\n        <div className={cx(\"afvscr-nonst\",className)} {...props}>\n            {headlessMode ? null : (\n                <TableWrapper className=\"afvscr-nonst-subtable\">\n                    <Thead />\n                </TableWrapper>\n            )}\n            <ScrollContainer ref={scrollContainerRef} onScroll={onScroll} reportScrollLeft>\n                {useMemo(() => (\n                    <BodyTable fixedLayout={fixedLayout}>\n                        <Colgroup />\n                        {headlessMode ? null : (\n                            <Thead\n                                className=\"afvscr-hdnwrp\"\n                                trRef={widthsObserverRef}\n                            />\n                        )}\n                        {totals && (\n                            <Tfoot\n                                TotalsCellComponent={TotalsCellComponent}\n                                className=\"afvscr-hdnwrp\"\n                                trRef={headlessMode?widthsObserverRef:undefined}\n                            />\n                        )}\n                        <TbodyScroller />\n                        <Tbody\n                            tbodyRef={tbodyRef}\n                            getRowExtraProps={getRowExtraProps}\n                            getCellExtraProps={getCellExtraProps}\n                            RowComponent={RowComponent}\n                            CellComponent={CellComponent}\n                        />\n                    </BodyTable>\n                ), [ totals, headlessMode, fixedLayout, getRowExtraProps, getCellExtraProps, RowComponent, CellComponent, TotalsCellComponent ])}\n            </ScrollContainer>\n            {totals && (\n                <TableWrapper className=\"afvscr-nonst-subtable\">\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                </TableWrapper>\n            )}\n        </div>\n    );\n};\n\nexport default memo( NonSticky );","import React, { memo, useMemo, useEffect } from \"react\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport Thead from \"../common/Thead\";\nimport Tbody from \"../common/Tbody\";\nimport Tfoot from \"../common/Tfoot\";\nimport BodyTable from \"../common/BodyTable\";\nimport useApi from \"../../useApi\";\nimport cx from \"../../utils/cx\";\n\nconst SUBSCRIBE_EVENTS = [\n    \"#headlessMode\",\n    \"#totals\"\n];\n\n\n/*\n    Todo:\n        measure thead & tfoot heights in order to properly calculate available space for rows\n*/\n\n\nconst Sticky = ({\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    fixedLayout,\n    className,\n    ...props\n}) => {\n\n    const { headlessMode, totals } = useApi( SUBSCRIBE_EVENTS );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        /*\n            https://bugs.chromium.org/p/chromium/issues/detail?id=702927\n        */\n\n        const areTotalsPresent = totals && totals.length !== 0;\n\n        useEffect(() => {\n            if( !headlessMode || areTotalsPresent ){\n\n                const table = scrollContainerRef.current.querySelector( \"table\" );\n                const tableStyle = getComputedStyle( table );\n\n                if( tableStyle.borderCollapse === \"collapse\" ){\n                    console.warn(\n                        \"You use sticky table version. Due to special border behavior when scrolling, use border-collpase: separate.%o\",\n                        \"https://bugs.chromium.org/p/chromium/issues/detail?id=702927\"\n                    );\n                }\n            }\n        }, [ headlessMode, areTotalsPresent ]);\n    }\n    \n    return (\n        <ScrollContainer ref={scrollContainerRef} reportScrollLeft className={cx(\"afvscr-st\",className)} {...props}>\n            {useMemo(() => (\n                <BodyTable fixedLayout={fixedLayout}>\n                    <Colgroup />\n                    {headlessMode?null:<Thead />}\n                    <TbodyScroller />\n                    <Tbody\n                        tbodyRef={tbodyRef}\n                        getRowExtraProps={getRowExtraProps}\n                        getCellExtraProps={getCellExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                    />\n                    {totals && (\n                        <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                    )}\n                </BodyTable>\n            ), [ headlessMode, fixedLayout, totals, getRowExtraProps, getCellExtraProps, RowComponent, CellComponent, TotalsCellComponent ])}\n        </ScrollContainer>\n    );\n}\n\nexport default memo( Sticky );","const commonDefaultProps = {\n    fixedSize: false,\n    rowCount: 0,\n    overscanRowsCount: 4\n};\n\nexport default commonDefaultProps;","import React, { memo, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport isPositionStickySupported from \"../utils/isPositionStickySupported\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\n\nimport FixedSizeTableStore from \"../models/FixedSizeTable\";\nimport VariableSizeTableStore from \"../models/VariableSizeTable\";\n\nimport RowComponentDefault from \"./common/Row\";\nimport CellComponentDefault from \"./common/Cell\";\nimport TotalsCellComponentDefault from \"./common/TotalsCell\";\n\nimport RowCountWarningContainerDefault from \"../common/RowCountWarningContainer\";\n\nimport NonStickyComponent from \"./NonSticky\";\nimport StickyComponent from \"./Sticky\";\n\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nconst Table = ({\n    fixedSize,\n    columns,\n    totals,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    rowCount,\n    overscanRowsCount,\n    rowCountWarningsTable,\n    headless,\n    RowCountWarningContainer,\n    dataRef,\n    useStickyIfPossible,\n    className,\n    ...props\n}) => {\n\n    const scrollContainerRef = useRef();\n    const tbodyRef = useRef();\n\n    const Store = useStore( fixedSize ? FixedSizeTableStore : VariableSizeTableStore, dataRef );\n\n    useEffect(() => {\n        Store.merge({\n            headlessMode: headless,\n            rowDataGetter: getRowData,\n            rowKeyGetter: getRowKey,\n            overscanRowsCount,\n            totals,\n            columns,\n            totalRows: Math.max( rowCount, 0 ),\n            rowsContainerNode: tbodyRef.current,\n            scrollContainerNode: scrollContainerRef.current\n        });\n    });\n\n    /*\n        Only cells inside thead/tfoot can be sticky.\n        If thead/tfoot are hidden - we can easily render lighter StickyComponent to avoid extra wrappers\n    */\n    const ComponentVariant = ( headless && !totals ) || ( useStickyIfPossible && isPositionStickySupported() ) ? StickyComponent : NonStickyComponent;\n\n    return (\n        <Context.Provider value={Store}>\n            { rowCount > 0 ? (\n                <ComponentVariant\n                    className={cx(\"afvscr-table-wrapper\",className)}\n                    scrollContainerRef={scrollContainerRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    tbodyRef={tbodyRef}\n                    {...props}\n                />\n            ) : rowCountWarningsTable ? (\n                <RowCountWarningContainer>\n                    {rowCountWarningsTable[rowCount]}\n                </RowCountWarningContainer>\n            ) : null }\n        </Context.Provider>\n    );\n}\n\nTable.propTypes = {\n    ...commonPropTypes,\n    columns: PropTypes.arrayOf(\n        PropTypes.shape({\n            // unique key for column\n            dataKey: PropTypes.string.isRequired,\n\n            // If rowData is available, cellData goes through flow, where each fn is optional: render(format((getCellData(rowData,rowIndex))),rowData)\n            // If not, it goes through flow: getEmptyCellData(rowIndex, column).\n            getCellData: PropTypes.func,\n            getEmptyCellData: PropTypes.func,\n            format: PropTypes.func,\n            formatTotal: PropTypes.func,\n\n            visibility: PropTypes.oneOf([ \"visible\", \"hidden\" ]),\n            sort: PropTypes.oneOf([ \"locale\", \"numeric\" ]),\n\n            // column props, affecting colgroup > col tags\n            background: PropTypes.string,\n            border: PropTypes.string,\n            width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n            CellComponent: PropTypes.any,\n            getCellExtraProps: PropTypes.func\n        })\n    ).isRequired,\n\n    getCellExtraProps: PropTypes.func,\n\n    totals: PropTypes.objectOf(\n        // array may contain: \"sum\", \"average\", \"count\", \"max\", \"min\"\n        PropTypes.array\n    ),\n    \n    useStickyIfPossible: PropTypes.bool,\n    headless: PropTypes.bool,\n\n    HeaderRowComponent: PropTypes.any,\n    CellComponent: PropTypes.any,\n    TotalsCellComponent: PropTypes.any,\n\n    RowCountWarningContainer: PropTypes.any,\n    rowCountWarningsTable: PropTypes.object,\n\n    // Determines, if table-layout: fixed is applied to main table\n    fixedLayout: PropTypes.bool\n};\n\nTable.defaultProps = {\n    ...commonDefaultProps,\n    fixedLayout: false,\n    headless: false,\n\n    //    For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n    //    If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n    //    memo(observer(RowComponentDefault)) will do the trick.\n    \n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    TotalsCellComponent: TotalsCellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default memo( Table );","import React from \"react\";\nimport Table from \"af-virtual-scroll/src/Table\";\nimport r from \"lodash/random\";\nimport times from \"lodash/times\";\nimport faker from \"faker\";\nimport { css } from \"@emotion/core\";\n\nconst tableCss = css`\n    th, tfoot td {\n        background: #fff;\n    }\n`;\n\nconst columns = [\n    {\n        dataKey: \"rowIndex\",\n        label: \"Row index\",\n        getCellData: ( rowData, i ) => i\n    },\n    {\n        dataKey: \"num\",\n        label: \"Numeric\",\n        sort: \"numeric\"\n    },\n    {\n        dataKey: \"str\",\n        label: \"String\",\n        sort: \"locale\"\n    },\n    {\n        dataKey: \"rect\",\n        label: \"Rectangle\",\n        render: cellData => (\n            <div style={{\n                lineHeight: `${cellData}px`,\n                background: `hsl(${r(0,360)},50%,50%)`\n            }}>\n                height: {cellData}px\n            </div>\n        )\n    }\n];\n\nconst rowCount = 100000;\n\nconst rows = times( rowCount, () => ({\n    num: r( 1, 20000 ),\n    str: faker.name.findName(),\n    rect: r( 50, 250 )\n}));\n\nconst getRowData = index => rows[ index ];\n\nconst totals = {\n    num: [ \"sum\", \"count\" ]\n};\n\nconst VariableRowHeightsTable = ({ className }) => (\n    <Table\n        css={tableCss}\n        className={className}\n        useStickyIfPossible\n        totals={totals}\n        getRowData={getRowData}\n        rowCount={rowCount}\n        columns={columns}\n    />\n);\n\nexport default VariableRowHeightsTable;"],"sourceRoot":""}