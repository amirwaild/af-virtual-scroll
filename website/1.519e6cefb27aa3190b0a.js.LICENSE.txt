/*
              * aria-rowindex is counted from 1 according to w3c spec;
              * parseInt with radix is 2x faster, then +, -, etc.
                https://jsperf.com/number-vs-parseint-vs-plus/116
          */

/*
            Some benchmarks inspire me to use nextElementSibling
            https://jsperf.com/nextsibling-vs-childnodes-increment/2
        */

/*
            TODO:
                make tree[ 0 ] more obvious and self-documented
        */

/*
          when using ...args and arrow func, babel is making unnecessary arguments copy.
          Going old-school here for perf
      */

/*
        TODO:
            perf benchmarks tell, that removeChild is called often.
            maybe cache previous range( endIndex - startIndex ) and if new range is smaller - throttle it's decrease?
    */

/*
        Uint16 cannot be used here, because array stores intermediate sums, which can be huge.
    */

/*
        column props, affecting colgroup > col tags
    */

/*
        walkUntil works by "strict less" algo. It is good for startIndex,
        but for endIndex we need "<=", so adding 1 artificially.
    */

/*
      For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.
      If RowComponent should be wrapped my mobx observer - non-memo version should be imported.
      memo(observer(RowComponentDefault)) will do the trick.
  */

/*
      IDEA:
          pack this to one double number.
          num + remianer / 65535
          Cons:
              * unobvious
              * perf fault because of double type costs.
  */

/*
      Only cells inside thead/tfoot can be sticky.
      If thead/tfoot are hidden - we can easily render lighter StickyComponent to avoid extra wrappers
  */

/*
      TODO:
          make this call throttled
  */

/*
      TODO: maybe some react-like performUnitOfWork logic is needed here?
  */

/*
      Trees are not always ideally allocated, gaps are possible.
      Classical way for calculating parents is much simpler,
      but can do much more work(summing zeros) in such conditions. Commented classic algo:
       for( let i = N + endIndex >> 1, j; i > 0; --i ){
          j = i << 1;
          tree[ i ] = tree[ j ] + tree[ j | 1 ];
      }
  */

/*
      We do not want to recalculate totals too often, so caching them in object by column dataKey
  */

/*
      tabIndex="0" is for proper keyboard nav
      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159
  */

/*
    flex: 1 1 auto, assuming that table would be used full-stretch mostly
*/

/*
  TODO: maybe this is needed on #totalRows? Check
   cancelPendingAsyncCallsIfNeeded(){
      if( this.totalRows < 0 ){
          this.cancelPendingAsyncCalls();
      }
  }
  */

/* 
        If rowData is available, cellData goes through flow, where each fn is optional: render(format((getCellData(rowData,rowIndex))),rowData)
        If not, it goes through flow: getEmptyCellData(rowIndex, column).
    */

/* Determines, if table-layout: fixed is applied to main table */

/* Hmm, I can't put translateY more than ~ 3 000 000. Maybe need to figure this out) */

/* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */

/* In segments tree 1 node is always sum of all elements */

/* Todo: optimize, if we already calculated sum */

/* array may contain: "sum", "average", "count". */

/* clearing only what is needed */

/* harmony default export */

/* harmony import */

/* unique key for column */

/*#__PURE__*/

/***/

// CONCATENATED MODULE: ./lib/Table/common/Tfoot/index.js

// CONCATENATED MODULE: ./lib/models/FixedSizeList/index.js

// EXTERNAL MODULE: ./lib/Table/common/Cell/index.js

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js

// EXTERNAL MODULE: ./node_modules/emotion/dist/emotion.esm.js + 1 modules

// console.log( "%d| was: %d; is: %d", index, tree[N+index],newHeight)
