/*
         * Don't catch and rethrow exceptions. This is useful for inspecting the state of
         * the stack when an exception occurs while debugging.
         */

/*
         * If true, we are already handling an exception in an action. Any errors in reactions should be suppressed, as
         * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
         */

/*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */

/*
The only reason for this file to exist is pure horror:
Without it rollup can make the bundling fail at any point in time; when it rolls up the files in the wrong order
it will cause undefined errors (for example because super classes or local variables not being hoisted).
With this file that will still happen,
but at least in this file we can magically reorder the imports with trial and error until the build succeeds again.
*/

/* WEBPACK VAR INJECTION */

/* global Reflect, Promise */

/* harmony export (binding) */

/* harmony import */

/* see #1208 */

/* unused harmony export $mobx */

/* unused harmony export FlowCancellationError */

/* unused harmony export IDerivationState */

/* unused harmony export ObservableMap */

/* unused harmony export ObservableSet */

/* unused harmony export Observer */

/* unused harmony export _allowStateChanges */

/* unused harmony export _allowStateChangesInsideComputed */

/* unused harmony export _allowStateReadsEnd */

/* unused harmony export _allowStateReadsStart */

/* unused harmony export _endAction */

/* unused harmony export _getAdministration */

/* unused harmony export _getGlobalState */

/* unused harmony export _interceptReads */

/* unused harmony export _isComputingDerivation */

/* unused harmony export _resetGlobalState */

/* unused harmony export _startAction */

/* unused harmony export action */

/* unused harmony export autorun */

/* unused harmony export comparer */

/* unused harmony export computed */

/* unused harmony export createAtom */

/* unused harmony export decorate */

/* unused harmony export entries */

/* unused harmony export extendObservable */

/* unused harmony export flow */

/* unused harmony export get */

/* unused harmony export getAtom */

/* unused harmony export getDebugName */

/* unused harmony export getObserverTree */

/* unused harmony export has */

/* unused harmony export intercept */

/* unused harmony export isAction */

/* unused harmony export isArrayLike */

/* unused harmony export isBoxedObservable */

/* unused harmony export isComputed */

/* unused harmony export isComputedProp */

/* unused harmony export isFlowCancellationError */

/* unused harmony export isObservable */

/* unused harmony export isObservableArray */

/* unused harmony export isObservableMap */

/* unused harmony export isObservableObject */

/* unused harmony export isObservableProp */

/* unused harmony export isObservableSet */

/* unused harmony export isObserverBatched */

/* unused harmony export isUsingStaticRendering */

/* unused harmony export keys */

/* unused harmony export observe */

/* unused harmony export observerBatching */

/* unused harmony export observerBatchingOptOut */

/* unused harmony export onBecomeObserved */

/* unused harmony export onBecomeUnobserved */

/* unused harmony export onReactionError */

/* unused harmony export reaction */

/* unused harmony export remove */

/* unused harmony export set */

/* unused harmony export toJS */

/* unused harmony export trace */

/* unused harmony export untracked */

/* unused harmony export useAsObservableSource */

/* unused harmony export useForceUpdate */

/* unused harmony export useLocalStore */

/* unused harmony export useObserver */

/* unused harmony export useStaticRendering */

/* unused harmony export values */

/* unused harmony export when */

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/*#__PURE__*/

/**
         * 'guid' for general purpose. Will be persisted amongst resets.
         */

/**
         * (Experimental)
         * Warn if observables are accessed outside a reactive context
         */

/**
         * (Experimental)
         * Warn if you try to create to derivation / reactive context without accessing any observable.
         */

/**
         * Allows overwriting of computed properties, useful in tests but not prod as it can cause
         * memory leaks. See https://github.com/mobxjs/mobx/issues/1867
         */

/**
         * Are we currently processing reactions?
         */

/**
         * Are we in a batch block? (and how many of them)
         */

/**
         * Are we running a computation currently? (not a reaction)
         */

/**
         * Currently running derivation
         */

/**
         * Each time a derivation is tracked, it is assigned a unique run-id
         */

/**
         * Globally attached error handlers that react specifically to errors in reactions
         */

/**
         * If strict mode is enabled, state changes are by default not allowed
         */

/**
         * Is it allowed to change observables at this point?
         * In general, MobX doesn't allow that when running computations and React.render.
         * To ensure that those functions stay pure.
         */

/**
         * Is it allowed to read observables at this point?
         * Used to hold the state needed for `observableRequiresReaction`
         */

/**
         * List of scheduled, not yet executed, reactions.
         */

/**
         * MobXGlobals version.
         * MobX compatiblity with other versions loaded in memory as long as this version matches.
         * It indicates that the global state still stores similar information
         *
         * N.B: this version is unrelated to the package version of MobX, and is only the version of the
         * internal state storage of MobX, and can be the same across many different package versions
         */

/**
         * Observables that don't have observers anymore, and are about to be
         * suspended, unless somebody else accesses it in the same batch
         *
         * @type {IObservable[]}
         */

/**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */

/**
         * Spy callbacks
         */

/**
         * This happens if a property is accessed through the prototype chain, but the property was
         * declared directly as own property on the prototype.
         *
         * E.g.:
         * class A {
         * }
         * extendObservable(A.prototype, { x: 1 })
         *
         * classB extens A {
         * }
         * console.log(new B().x)
         *
         * It is unclear whether the property should be considered 'static' or inherited.
         * Either use `console.log(A.x)`
         * or: decorate(A, { x: observable })
         *
         * When using decorate, the property will always be redeclared as own property on the actual instance
         */

/**
         * Warn if computed values are accessed outside a reactive context
         */

/**
         * globally unique token to signal unchanged
         */

/**
     * Converts this array back to a (shallow) javascript structure.
     * For a deep clone use mobx.toJS
     */

/**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */

/**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce a new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */

/**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */

/**
     * Invoke this method to notify mobx that your atom has been used somehow.
     * Returns true if there is currently a reactive context.
     */

/**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */

/**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */

/**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */

/**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */

/**
     * internal, use schedule() if you intend to kick off a reaction
     */

/**
 * (c) Michel Weststrate 2015 - 2018
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */

/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */

/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */

/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */

/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */

/**
 * Makes sure that the provided function is invoked at most once.
 */

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */

/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */

/**
 * Returns the following: own keys, prototype keys & own symbol keys, if they are enumerable.
 */

/**
 * Returns whether the argument is an array, disregarding observability.
 */

/**
 * Run by the cleanup timer to dispose any outstanding reactions
 */

/**
 * The frequency with which we'll check for leaked reactions.
 */

/**
 * The minimum time before we'll clean up a Reaction created in a render
 * for a component that hasn't managed to run its effects. This needs to
 * be big enough to ensure that a component won't turn up and have its
 * effects run without being re-rendered.
 */

/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */

/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */

/** @class */

/** Merge another object into this object, returns this. */

/** MobX - (c) Michel Weststrate 2015 - 2020 - MIT Licensed */

/***/

//

//             " < " +

//             " because " +

//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance

//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance

//             min +

//             msg +

//             newDepState === IDerivationState.NOT_TRACKING)

//             observable.lowestObserverState

//         "INTERNAL ERROR there is no junk in map"

//         "lowestObserverState is wrong for " +

//         (newDepState === IDerivationState.POSSIBLY_STALE ||

//         const id = list[i].__mapid

//         fail("Illegal dependency state")

//         if (i) {

//         list.length === 0 || Object.keys(map).length === list.length - 1,

//         process.env.NODE_ENV === "production" &&

//         }

//         } else {

//     )

//     // it's expensive so better not run it in produciton. but temporarily helpful for testing

//     const l = list.length

//     const list = observable.observers

//     const map = observable.observersIndexes

//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)

//     const newDepState = (derivation as any).dependenciesState

//     for (let i = 0; i < l; i++) {

//     if (

//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`

//     invariant(

//     throw new Error(

//     }

//    since it wouldn't be a callable function anymore

//   0: it was set to 0 in last loop. don't need to do anything.

//   0: it's not in new observables, unobserve it

//   1: it keeps being observed, don't want to notify it. change to 0

//   1: it wasn't observed, let's observe it. set back to 0

// (It triggers warnings in StrictMode, for a start.)

// *all* enumerables

// *own* symbols

// 1. it cannot go before memo, only after it

// 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it

// @action fn() {}

// @action method() { }

// @action("name") fn() {}

// @decorator

// @decorator(args)

// @observable someProp;

// A shallow dependency has changed since last computation and the derivation

// Add the first object to the stack of traversed objects.

// An `egal` comparison is performed for other numeric values.

// Assume equality for cyclic structures. The algorithm for detecting cyclic

// BUT if we're a component that hasn't yet got to the useEffect()

// Build property key array from both strings and symbols

// But: https://github.com/mobxjs/mobx/issues/1556

// Called by Atom when its value changes

// Called by ComputedValue when it recalculate and its value changed

// Called on first mount only

// Coerce dates and booleans to numeric primitive values. Dates are compared by their

// Compare `[[Class]]` names.

// Compare array lengths to determine if a deep comparison is necessary.

// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289

// Deep compare each member

// Deep compare objects.

// Deep compare the contents, ignoring non-numeric properties.

// Empty

// Ensure that both objects contain the same number of properties before comparing deep equality.

// Exhaust primitive checks

// Extra process checks, as this happens during module initialization

// First render for this component (or first time since a previous

// Fixes #1740

// Forcing instance now, fixes hot reloadig issues on React Native:

// Go through all new observables and check diffValue: (now it should be unique)

// Go through all old observables and check diffValue: (it is unique after last bindDependencies)

// Great. We've already got our reaction from our render;

// Hence we work with two variables and check whether

// Hide this extra level by increasing the depth.

// Ideally we use for..of here, but the downcompiled version is really slow...

// Identical objects are equal. `0 === -0`, but they aren't identical.

// Initializers run lazily when transpiling to babel, so make sure they are run...

// Initializing stack of traversed objects.

// Interceptor can modify the array, copy it to avoid concurrent modification, see #1950

// Internal recursive comparison function for `isEqual`.

// It's done here since we only need them for objects and arrays comparison.

// It's time to tidy up this leaked reaction.

// Linear search. Performance is inversely proportional to the number of

// Loop through all the candidate leaked reactions; those older

// MWE: not the fastest, but the easiest way :)

// MWE: should `in` operator be reactive? If not, below code path will be faster / more memory efficient

// Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.

// N.B: we can't immediately invoke initializer; this would be wrong

// No Array.fill everywhere...

// Note: this implementation is missing enumerable, inherited, symbolic property names! That would however pretty expensive to add,

// Object(NaN) is equivalent to NaN.

// Objects with different constructors are not equivalent, but `Object`s or `Array`s

// Observable has changed, meaning we want to re-render

// Optimization: faster on decorator target or instance? Assuming target

// Optimization: find out if declaring on instance isn't just faster. (also makes the property descriptor simpler). But, more memory usage..

// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,

// Possible optimization: Don't have a separate map for non existing keys,

// Predefined bags of create observable options, to avoid allocating temporarily option objects

// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is

// Re-create the reaction

// Recursively compare objects and arrays.

// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

// Remove the first object from the stack of traversed objects.

// See #1072

// See e.g. https://github.com/mobxjs/mobx/issues/859

// See perf test 'computed memoization'

// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).

// See: https://github.com/andykog/mobx-devtools/

// Should never be possible to change an observed observable from inside computed, see #798

// Should not be possible to change observed state outside strict mode, except during initialization, see #563

// Simple property that writes on first invocation to the current instance

// Some new observed derivations may become stale during this derivation computation

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// Strings, numbers, regular expressions, dates, and booleans are compared by value.

// TODO: check performance stats!

// TODO: ideally, value = change.value would be done here, so that values can be

// The reaction we set up in our render has been disposed.

// The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307

// This fixes #1796, because deleting a prop that has an

// This is either due to bad timings of renderings, e.g. our

// Trampolining, if runReactions are already running, new reactions will be picked up

// Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

// Unwrap any wrapped objects.

// Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,

// Used by JSON.stringify

// Used by computed when its dependency changed, but we don't wan't to immediately recompute.

// We have reached useEffect(), so we're mounted, and can trigger an update

// We haven't yet reached useEffect(), so we'll need to trigger a re-render

// We lie about symbol key types due to https://github.com/Microsoft/TypeScript/issues/1863

// We've definitely already been mounted at this point

// We've just finished a round of cleanups but there are still

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// While running reactions, new reactions might be triggered.

// `NaN`s are equivalent, but non-reflexive.

// `null` or `undefined` only equal to itself (strict comparison).

// action("name", fn() {})

// action(fn() {})

// add a new item

// all we need to do is to record that it's now mounted,

// and `derivation` is an observer of `obj`

// and delete them from the map, then merge the new map

// and skip either the internal values map, or the base object with its property descriptors!

// apply modifier

// apply to instance immediately

// array will be trimmed by bindDependencies

// as there is no efficient iterator that returns *all* properties

// at this point derivation is not holding any data about dependency tree

// babel / typescript

// babel only: @action method = () => {}

// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js

// because computed props are declared on proty,

// before being run or (outside batch and not being observed)

// between render and useEffect

// bound instance methods

// but store them in the values map instead, using a special symbol to denote "not existing"

// cached from whatever global is present so that test runners that stub it

// changed by interceptor. Same applies for other Set and Map api's.

// component was paused for a _very_ long time, and our

// computed values are automatically teared down when the last observer leaves

// conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

// currently only ComputedValue will propagate POSSIBLY_STALE

// debounced autorun

// default `noop` listener will not initialize the hook Set

// delete the prop

// deleting last observer

// disposed during last run. Clean up everything that was bound after the dispose call.

// disposer function

// don't break things.  But we need to wrap it in a try catch in case it is

// don't have to recompute on every dependency change, but only when it's needed

// drop our current reaction and allow useEffect() to recreate it.

// during tracking it's an array with new observed observers

// empty string to avoid regexp issues

// equivalent to `new String("5")`.

// for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

// from different frames are.

// function because try/catches deoptimize in certain engines.

// function invariantLOS(observable: IObservable, msg: string) {

// function invariantObservers(observable: IObservable) {

// function invariantShouldCompute(derivation: IDerivation) {

// got dropped, and we don't want to make state changes then.

// grab all the keys that are present in the new map but not present in the current map

// having this state is second big optimization:

// if (adm.values.get(name as string)) return true

// if ComputedValue `obj` actually changed it will be computed and propagated to its observers.

// if clearTimeout wasn't available but was latter defined

// if disposed while running, clean up later. Maybe not optimal, but rare case

// if setTimeout wasn't available but was latter defined

// if this observable had reactive observers, trigger the hooks

// in the majority of cases

// initialValue is the descriptor for get / set props

// intercept

// invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");

// invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");

// invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");

// invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");

// invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");

// invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");

// invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");

// invariantLOS(observable, "changed start");

// invariantLOS(observable, "confirmed start");

// invariantLOS(observable, "maybe start");

// invariantObservers(observable);

// invariantShouldCompute(derivation)

// it is an observable already, done

// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54

// make sure object is observable, even without initial props

// make sure we start listening to future keys

// millisecond representations. Note that invalid dates with millisecond representations

// mobx versions

// never turn into an observable

// newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)

// no shallow dependency changed since last computation

// nodes we are looking at. Our value depends on these nodes

// normal autorun

// not hitting the condition

// note that we only do this here for optimization

// notify key and keyset listeners

// notify spy & observers

// numeric string

// observableValue might have changed it

// of `NaN` are not equivalent.

// otherwise, just box it

// out of bounds

// pre allocate array allocation + room for variation in deps

// prettier-ignore

// process.env.NODE_ENV !== "production" &&

// re-throw any exceptions catched during rendering

// reaction from an abandoned render was disposed).

// reaction got cleaned up, or we got a observable change

// read to subscribe

// return Reflect.ownKeys(this.values) as any

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// shim for using process in browser

// so they have had no chance to propagate staleness (#916)

// some deep dependency changed, but don't know if shallow dependency changed

// some leak candidates outstanding.

// something that can be converted and mutated?

// stage, we might be a component that _started_ to render, but

// state propagation can occur outside of action/reactive context #2195

// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

// than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.

// the autorun wouldn't subscribe to future key changes (see also next comment)

// the batch is actually about to finish, all unobserving should happen here.

// the current instance might not have been initialized yet

// this is what makes mobx fast

// this process happens recursively, this computed might be the last observabe of another, etc..

// this value could be converted to a new observable data structure, return it

// this will cause reactions only on changed values

// to allow future observable changes to trigger re-renders

// to check for cycles

// todo: replace with atom (breaking change)

// typescript

// undefined value won't retrigger a observer (no visible effect),

// unique nested structures.

// unreachable

// update at index in range

// v8 likes predictible objects

// valid for arrays as well

// value might have been changed

// we are not interested in the value *or* exception at this moment, but if there is one, notify all

// we converge to no remaining reactions after a while.

// we don't use globalState for these in order to avoid possible issues with multiple

// we have to use forwardRef here because:

// weird trick to keep our typings nicely with our funcs, and still extend the observable function

// when (and if) useEffect() arrives.  The easiest way to do that is just to

// when when somebody has screwed with setTimeout but no I.E. maddness

// where is the property declared?

// will need to recompute when it's needed next.

// will require to check first if UP_TO_DATE or POSSIBLY_STALE

// won't recalculate derivation

// wrapped in strict mode code which doesn't define any globals.  It's inside a

// }

//normal enviroments in sane situations
